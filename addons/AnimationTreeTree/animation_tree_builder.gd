# spinalcord
# https://github.com/spinalcord/animation-tree-tree-godot
# 
# This file is part of animation-tree-tree-godot.
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public.
#
# NOTE: The output generated by this addon is not affected by this license.

# AnimationTreeBuilder.gd
class_name AnimationTreeBuilder
extends RefCounted

var _tree: AnimationTree

# ============================================================================
# INITIALIZATION
# ============================================================================

func _init(animation_tree: AnimationTree) -> void:
	_tree = animation_tree

func _get_animation_player() -> AnimationPlayer:
	var anim_player_path = _tree.anim_player
	if _tree.anim_player != NodePath():
		return _tree.get_node(_tree.anim_player) as AnimationPlayer
	return null
		
# ============================================================================
# NODE OPERATIONS
# ============================================================================

# Add an existing node (for paste operations)
# Add an existing node (for paste operations)
func add_existing_node(parent_path: String, node: AnimationNode, node_name: String, position: Vector2 = Vector2.ZERO) -> bool:
	if not _validate_tree():
		TreeDebug.msg("Invalid AnimationTree", true)
		return false
	
	var parent = _get_node_at_path(parent_path)
	if not _can_add_to(parent):
		TreeDebug.msg("Parent cannot accept children: " + parent_path, true)
		return false
	
	if not is_instance_valid(node):
		TreeDebug.msg("Invalid node provided", true)
		return false
	
	if _add_to_container(parent, node, node_name, position):
		TreeDebug.msg("Added existing node: " + parent_path + "/" + node_name)
		return true
	
	TreeDebug.msg("Failed to add existing node", true)
	return false

# Get the last added blend point node from a BlendSpace
func get_last_blend_point_node(parent_path: String) -> AnimationNode:
	var parent = _get_node_at_path(parent_path)
	
	if parent is AnimationNodeBlendSpace1D:
		var bs1d = parent as AnimationNodeBlendSpace1D
		var count = bs1d.get_blend_point_count()
		if count > 0:
			return bs1d.get_blend_point_node(count - 1)
	elif parent is AnimationNodeBlendSpace2D:
		var bs2d = parent as AnimationNodeBlendSpace2D
		var count = bs2d.get_blend_point_count()
		if count > 0:
			return bs2d.get_blend_point_node(count - 1)
	
	return null

func add_node(parent_path: String, config: Dictionary) -> bool:
	if not _validate_tree():
		TreeDebug.msg("Invalid AnimationTree", true)
		return false
	
	if not config.has("type"):
		TreeDebug.msg("Node config must have 'type' field", true)
		return false
	
	var parent = _get_node_at_path(parent_path)
	if not _can_add_to(parent):
		TreeDebug.msg("Parent cannot accept children: " + parent_path, true)
		return false
	
	var node = _create_node_instance(config["type"])
	if not is_instance_valid(node):
		TreeDebug.msg("Failed to create node of type: " + str(config["type"]), true)
		return false
	
	# Set animation property for Animation nodes
	if config.has("animation") and node is AnimationNodeAnimation:
		node.animation = config["animation"]
	
	# Apply additional properties
	if config.has("properties"):
		for key in config["properties"]:
			if key in node:
				node.set(key, config["properties"][key])
	
	# Determine name and position
	# Determine name and position
	var final_name = config.get("name", _generate_name(node))
	var final_position = config.get("position", _calculate_position(parent))
	
	# Extract blend_position for BlendSpace nodes
	var blend_position = null
	if config.has("properties") and config["properties"].has("blend_position"):
		var bp = config["properties"]["blend_position"]
		if bp is Dictionary:
			if bp.has("x") and bp.has("y"):
				blend_position = Vector2(bp["x"], bp["y"])
			elif bp.has("x"):
				blend_position = bp["x"]
		elif bp is Vector2:
			blend_position = bp
		elif bp is float or bp is int:
			blend_position = float(bp)
	
	if _add_to_container(parent, node, final_name, final_position, blend_position):
		TreeDebug.msg("Added node: " + parent_path + "/" + final_name)
		return true
	
	TreeDebug.msg("Failed to add node")
	return false

# Rename a node
func rename_node(node_path: String, new_name: String) -> bool:
	if not _validate_tree():
		TreeDebug.msg("Invalid AnimationTree", true)
		return false
	
	var parent_path = NodeUtils.get_parent_path(node_path)
	var parent = _get_node_at_path(parent_path)
	var old_name = NodeUtils.get_node_name_from_path(node_path)
	
	if not is_instance_valid(parent):
		TreeDebug.msg("Parent not found: " + parent_path, true)
		return false
	
	if parent is AnimationNodeStateMachine:
		var sm = parent as AnimationNodeStateMachine
		if not sm.has_node(old_name):
			TreeDebug.msg("Node not found: " + old_name)
			return false
		
		if sm.has_node(new_name):
			TreeDebug.msg("Name already exists: " + new_name)
			return false
		
		sm.rename_node(old_name, new_name)
		_emit_changed(sm)
		TreeDebug.msg("Renamed: " + old_name + " -> " + new_name)
		return true
	
	elif parent is AnimationNodeBlendTree:
		var bt = parent as AnimationNodeBlendTree
		var node = bt.get_node(old_name)
		if not is_instance_valid(node):
			TreeDebug.msg("Node not found: " + old_name)
			return false
		
		new_name = _ensure_unique_name_blend(bt, new_name)
		var position = NodeUtils.get_node_position(bt, old_name)
		
		# Extract and remove connections
		var connections = _extract_blend_connections(bt, old_name)
		bt.remove_node(old_name)
		bt.add_node(new_name, node, position)
		_restore_blend_connections(bt, connections, old_name, new_name)
		
		_emit_changed(bt)
		TreeDebug.msg("Renamed: " + old_name + " -> " + new_name)
		return true
	
	TreeDebug.msg("Cannot rename node in this container type", true)
	return false

# Replace a node
func replace_node(node_path: String, new_node: AnimationNode) -> bool:
	if not _validate_tree():
		TreeDebug.msg("Invalid AnimationTree")
		return false
	
	var parent_path = NodeUtils.get_parent_path(node_path)
	var parent = _get_node_at_path(parent_path)
	var node_name = NodeUtils.get_node_name_from_path(node_path)
	
	if not is_instance_valid(parent):
		TreeDebug.msg("Parent not found: " + parent_path)
		return false
	
	if parent is AnimationNodeStateMachine:
		var sm = parent as AnimationNodeStateMachine
		if not sm.has_node(node_name):
			TreeDebug.msg("Node not found: " + node_name)
			return false
		
		sm.replace_node(node_name, new_node)
		_emit_changed(sm)
		TreeDebug.msg("Replaced node: " + node_name)
		return true
	
	TreeDebug.msg("Replace only supported for StateMachine nodes")
	return false

# Delete a node
func delete_node(node_path: String) -> bool:
	if not _validate_tree():
		TreeDebug.msg("Invalid AnimationTree", true)
		return false
	

	
	var parent_path = NodeUtils.get_parent_path(node_path)
	var parent = _get_node_at_path(parent_path)
	var node_name = NodeUtils.get_node_name_from_path(node_path)
	
	if not is_instance_valid(parent):
		TreeDebug.msg("Parent not found: " + parent_path, true)
		return false

	if parent is AnimationNodeBlendSpace1D or parent is AnimationNodeBlendSpace2D:
		print(parent)
		push_error("You cannot delete Blendspace1D/Blendspace2D points with AnimationTreeTree-Addon. You have to do it manually in the AnimationTree-Viewport.")
		return false
	
	if parent is AnimationNodeStateMachine:
		var sm = parent as AnimationNodeStateMachine
		if not sm.has_node(node_name):
			TreeDebug.msg("Node not found: " + node_name, true)
			return false
		
		sm.remove_node(node_name)
		_emit_changed(sm)
		TreeDebug.msg("Deleted node: " + node_path)
		return true
	
	elif parent is AnimationNodeBlendTree:
		var bt = parent as AnimationNodeBlendTree
		if not is_instance_valid(bt.get_node(node_name)):
			TreeDebug.msg("Node not found: " + node_name, true)
			return false
		
		bt.remove_node(node_name)
		_emit_changed(bt)
		TreeDebug.msg("Deleted node: " + node_path)
		return true
	
	push_error("Cannot delete node from this container", true)
	return false

# Delete multiple nodes
func delete_nodes(node_paths: Array[String]) -> bool:
	var all_success = true
	var deleted_count = 0
	
	for path in node_paths:
		if delete_node(path):
			deleted_count += 1
		else:
			all_success = false
			TreeDebug.msg("Failed to delete: " + path)
	
	TreeDebug.msg("Deleted " + str(deleted_count) + "/" + str(node_paths.size()) + " nodes")
	return all_success

# ============================================================================
# TRANSITION OPERATIONS
# ============================================================================

# Add a transition using dictionary configuration
# Config format:
# {
#   "from": "StateName",
#   "to": "StateName",
#   "switch_mode": String ("immidiate", "at_end", "sync"),
#   "advance_mode": bool, (true = auto (default), false = enabled)
#   "condition": String (optional, advance_condition name),
#   "expression": String (optional, advance_expression),
#   "fade_time": float (optional, default: 0.0),
#   "priority": int (optional, default: 1),
#   "reset": bool (optional, default: true),
#   "curve": Curve (optional),
#   "immediate": bool (optional, sets switch_mode to immediate),
# }
func add_transition(state_machine_path: String, config: Dictionary) -> bool:
	var errors = []
	
	# Validate AnimationTree
	if not _validate_tree():
		errors.append("Invalid AnimationTree")
	
	# Validate config structure
	if not config.has("from") or not config.has("to"):
		errors.append("Transition config must have 'from' and 'to' fields")
		# Early return here since we can't proceed without from/to
		if errors.size() > 0:
			TreeDebug.msg("Errors found: " + str(errors), true)
			return false
	
	# Get state machine
	var state_machine = _get_node_at_path(state_machine_path)
	if not state_machine is AnimationNodeStateMachine:
		errors.append("Not a StateMachine: " + state_machine_path)
		# Early return since we can't proceed without valid state machine
		if errors.size() > 0:
			TreeDebug.msg("Errors found: " + str(errors), true)
			return false
	
	var sm = state_machine as AnimationNodeStateMachine
	var from_state = config["from"]
	var to_state = config["to"]
	
	# Validate forbidden transitions
	if from_state == "End":
		errors.append("Cannot create transition FROM 'End' node")
	
	if to_state == "Start":
		errors.append("Cannot create transition TO 'Start' node")
	
	# Validate nodes exist
	if from_state != "Start" and from_state != "End":
		if not sm.has_node(from_state):
			errors.append("From state does not exist: " + from_state)
	
	if to_state != "Start" and to_state != "End":
		if not sm.has_node(to_state):
			errors.append("To state does not exist: " + to_state)
	
	# Check if transition already exists
	if sm.has_transition(from_state, to_state):
		errors.append("Transition already exists: " + from_state + " -> " + to_state)
	
	# Return result
	if errors.size() > 0:
		TreeDebug.msg("Errors found: " + str(errors), true)
		return false
	
	# Create transition
	var trans = AnimationNodeStateMachineTransition.new()
	
	# Set switch mode
	if config.has("switch_mode"):
		match config["switch_mode"]:
			"immediate":
				trans.switch_mode = AnimationNodeStateMachineTransition.SWITCH_MODE_IMMEDIATE
			"sync":
				trans.switch_mode = AnimationNodeStateMachineTransition.SWITCH_MODE_SYNC
			"at_end":
				trans.switch_mode = AnimationNodeStateMachineTransition.SWITCH_MODE_AT_END
	else:
		trans.switch_mode = AnimationNodeStateMachineTransition.SWITCH_MODE_IMMEDIATE
	# Set advance mode
	if config.has("advance_mode"):
		if config["advance_mode"] == true:
			AnimationNodeStateMachineTransition.ADVANCE_MODE_AUTO
		else:
			AnimationNodeStateMachineTransition.ADVANCE_MODE_ENABLED
	else:
		trans.advance_mode = AnimationNodeStateMachineTransition.ADVANCE_MODE_AUTO
	
	# Set condition/expression
	if config.has("condition"):
		trans.advance_condition = config["condition"]
	
	if config.has("expression"):
		trans.advance_expression = config["expression"]
	
	# Set other properties
	trans.xfade_time = config.get("fade_time", 0.0)
	trans.priority = config.get("priority", 1)
	trans.reset = config.get("reset", true)
	
	if config.has("curve"):
		trans.xfade_curve = config["curve"]
	
	sm.add_transition(from_state, to_state, trans)
	_emit_changed(sm)
	
	TreeDebug.msg("Added transition: " + from_state + " -> " + to_state)
	return true

# Delete multiple transitions
# Each dict in the array should have "from" and "to" keys
# Example: [{"from": "Idle", "to": "Walk"}, {"from": "Walk", "to": "Run"}]
func delete_transitions(state_machine_path: String, transitions: Array) -> bool:
	if not _validate_tree():
		TreeDebug.msg("Invalid AnimationTree", true)
		return false
	
	var state_machine = _get_node_at_path(state_machine_path)
	if not state_machine is AnimationNodeStateMachine:
		TreeDebug.msg("Not a StateMachine: " + state_machine_path, true)
		return false
	
	var sm = state_machine as AnimationNodeStateMachine
	var all_success = true
	var deleted_count = 0
	
	for trans_dict in transitions:
		if not trans_dict.has("from") or not trans_dict.has("to"):
			TreeDebug.msg("Transition dict must have 'from' and 'to' keys", true)
			all_success = false
			continue
		
		var from_state = trans_dict["from"]
		var to_state = trans_dict["to"]
		
		if not sm.has_transition(from_state, to_state):
			TreeDebug.msg("Transition not found: " + from_state + " -> " + to_state, true)
			all_success = false
			continue
		
		sm.remove_transition(from_state, to_state)
		deleted_count += 1
		TreeDebug.msg("Deleted transition: " + from_state + " -> " + to_state)
	
	if deleted_count > 0:
		_emit_changed(sm)
	
	TreeDebug.msg("Deleted " + str(deleted_count) + "/" + str(transitions.size()) + " transitions")
	return all_success

# Get all transitions for a state machine
func get_transitions(state_machine_path: String) -> Array[Dictionary]:
	var transitions: Array[Dictionary] = []
	
	var state_machine = _get_node_at_path(state_machine_path)
	if not state_machine is AnimationNodeStateMachine:
		return transitions
	
	var sm = state_machine as AnimationNodeStateMachine
	var count = sm.get_transition_count()
	
	for i in range(count):
		transitions.append({
			"from": sm.get_transition_from(i),
			"to": sm.get_transition_to(i),
			"transition": sm.get_transition(i)
		})
	
	return transitions

# ============================================================================
# MERGE OPERATIONS
# ============================================================================

# Merge multiple nodes into a new StateMachine
func merge_nodes(node_paths: Array[String], merged_name: String = "MergedStateMachine") -> bool:
	if not _validate_tree():
		TreeDebug.msg("Invalid AnimationTree")
		return false
	
	if node_paths.size() < 2:
		TreeDebug.msg("Need at least 2 nodes to merge")
		return false
	
	# Validate all nodes have same parent
	var parent_path = NodeUtils.get_parent_path(node_paths[0])
	for path in node_paths:
		if NodeUtils.get_parent_path(path) != parent_path:
			TreeDebug.msg("All nodes must have same parent")
			return false
	
	var parent = _get_node_at_path(parent_path)
	if not parent is AnimationNodeStateMachine:
		TreeDebug.msg("Can only merge nodes in StateMachine")
		return false
	
	var sm = parent as AnimationNodeStateMachine
	var node_names: Array[String] = []
	
	# Collect and validate node names
	for path in node_paths:
		var node_name = NodeUtils.get_node_name_from_path(path)
		if not sm.has_node(node_name):
			TreeDebug.msg("Node not found: " + node_name)
			return false
		if node_name == "Start" or node_name == "End":
			TreeDebug.msg("Cannot merge Start or End nodes")
			return false
		node_names.append(node_name)
	
	TreeDebug.msg("=== MERGE OPERATION START ===")
	
	# Create new StateMachine
	var new_sm = AnimationNodeStateMachine.new()
	merged_name = _ensure_unique_name_state(sm, merged_name)
	
	# Copy nodes
	var center_pos = Vector2.ZERO
	for node_name in node_names:
		var node = sm.get_node(node_name)
		var pos = NodeUtils.get_node_position(sm, node_name)
		
		if is_instance_valid(node):
			var copied = NodeUtils.deep_copy_node(node)
			new_sm.add_node(node_name, copied, pos)
			center_pos += pos
	
	center_pos = center_pos / node_names.size() if node_names.size() > 0 else Vector2(100, 100)
	
	# Collect transition data
	var transition_data = _collect_merge_transition_data(sm, node_names)
	
	# Create internal structure
	_create_internal_merge_structure(new_sm, transition_data["internal"], transition_data["incoming"], transition_data["outgoing"])
	
	# Add merged StateMachine to parent
	sm.add_node(merged_name, new_sm, center_pos)
	
	# Create external transitions
	_create_external_transitions_for_merge(sm, merged_name, transition_data["incoming"], transition_data["outgoing"])
	
	# Delete original nodes
	for node_name in node_names:
		sm.remove_node(node_name)
	
	_emit_changed(sm)
	TreeDebug.msg("=== MERGE COMPLETED ===")
	TreeDebug.msg("Merged " + str(node_names.size()) + " nodes into: " + merged_name)
	return true

# ============================================================================
# UTILITY / QUERY OPERATIONS
# ============================================================================

# Get node at path
func get_node(node_path: String) -> AnimationNode:
	return _get_node_at_path(node_path)

# Check if node exists
func has_node(node_path: String) -> bool:
	return NodeUtils.has_node_at_path(_tree.tree_root, node_path)

# Get all child node names
func get_child_names(node_path: String) -> Array[String]:
	var node = _get_node_at_path(node_path)
	if not is_instance_valid(node):
		return []
	
	return NodeUtils.get_container_children(node)

# Get node position
func get_node_position(node_path: String) -> Vector2:
	var parent_path = NodeUtils.get_parent_path(node_path)
	var parent = _get_node_at_path(parent_path)
	var node_name = NodeUtils.get_node_name_from_path(node_path)
	
	if not is_instance_valid(parent):
		return Vector2.ZERO
	
	return NodeUtils.get_node_position(parent, node_name)

# Set node position
func set_node_position(node_path: String, position: Vector2) -> bool:
	var parent_path = NodeUtils.get_parent_path(node_path)
	var parent = _get_node_at_path(parent_path)
	var node_name = NodeUtils.get_node_name_from_path(node_path)
	
	if not is_instance_valid(parent):
		TreeDebug.msg("Parent not found")
		return false
	
	if NodeUtils.set_node_position(parent, node_name, position):
		_emit_changed(parent)
		return true
	
	TreeDebug.msg("Cannot set position for this node type")
	return false

# ============================================================================
# INTERNAL HELPER METHODS
# ============================================================================

func _validate_tree() -> bool:
	return is_instance_valid(_tree) and is_instance_valid(_tree.tree_root)

func _get_node_at_path(path: String) -> AnimationNode:
	return NodeUtils.get_node_at_path(_tree.tree_root, path)

func _can_add_to(node: AnimationNode) -> bool:
	return is_instance_valid(node) and (node is AnimationNodeStateMachine or node is AnimationNodeBlendTree or node is AnimationNodeBlendSpace1D or node is AnimationNodeBlendSpace2D)

func _create_node_instance(type: String) -> AnimationNode:
	# Normalize type name - remove "AnimationNode" prefix if present
	var normalized_type = type
	if type.begins_with("AnimationNode"):
		normalized_type = type.substr(13)  # Remove "AnimationNode" prefix
	
	match normalized_type:
		"StateMachine":
			return AnimationNodeStateMachine.new()
		"BlendTree":
			return AnimationNodeBlendTree.new()
		"Animation":
			return AnimationNodeAnimation.new()
		"OneShot":
			return AnimationNodeOneShot.new()
		"Blend2":
			return AnimationNodeBlend2.new()
		"Blend3":
			return AnimationNodeBlend3.new()
		"BlendSpace1D":
			return AnimationNodeBlendSpace1D.new()
		"BlendSpace2D":
			return AnimationNodeBlendSpace2D.new()
		"TimeScale":
			return AnimationNodeTimeScale.new()
		"TimeSeek":
			return AnimationNodeTimeSeek.new()
		"Transition":
			return AnimationNodeTransition.new()
	return null

func _generate_name(node: AnimationNode) -> String:
	return "New" + node.get_class().replace("AnimationNode", "")

func _calculate_position(parent: AnimationNode) -> Vector2:
	if parent is AnimationNodeStateMachine:
		return _calculate_state_position(parent as AnimationNodeStateMachine)
	elif parent is AnimationNodeBlendTree:
		return _calculate_blend_position(parent as AnimationNodeBlendTree)
	return Vector2(100, 100)



func _calculate_state_position(sm: AnimationNodeStateMachine) -> Vector2:
	var node_list = NodeUtils.get_container_children(sm)
	if node_list.is_empty():
		return Vector2(100, 100)
	
	var rightmost_x = -999999.0
	var avg_y = 0.0
	var count = 0
	
	for node_name in node_list:
		var pos = NodeUtils.get_node_position(sm, node_name)
		if pos.x > rightmost_x:
			rightmost_x = pos.x
		avg_y += pos.y
		count += 1
	
	return Vector2(rightmost_x + 200, avg_y / count) if count > 0 else Vector2(100, 100)

func _calculate_blend_position(bt: AnimationNodeBlendTree) -> Vector2:
	var node_names = NodeUtils.get_container_children(bt)
	if node_names.is_empty():
		return Vector2(100, 100)
	
	var bottommost_y = -999999.0
	var avg_x = 0.0
	
	for node_name in node_names:
		var pos = NodeUtils.get_node_position(bt, node_name)
		if pos.y > bottommost_y:
			bottommost_y = pos.y
		avg_x += pos.x
	
	return Vector2(avg_x / node_names.size(), bottommost_y + 120)

func _add_to_container(parent: AnimationNode, node: AnimationNode, name: String, position: Vector2, blend_position = null) -> bool:
	if parent is AnimationNodeStateMachine:
		var sm = parent as AnimationNodeStateMachine
		name = _ensure_unique_name_state(sm, name)
		sm.add_node(name, node, position)
		_emit_changed(sm)
		return true
	elif parent is AnimationNodeBlendTree:
		var bt = parent as AnimationNodeBlendTree
		name = _ensure_unique_name_blend(bt, name)
		bt.add_node(name, node, position)
		_emit_changed(bt)
		return true
	elif parent is AnimationNodeBlendSpace1D:
		if not name.is_valid_int():
			push_error("BlendSpace children must have numeric names, got: " + name, true)
			return false
		
		var bs1d = parent as AnimationNodeBlendSpace1D
		var pos_1d: float = 0.0
		if blend_position is float or blend_position is int:
			pos_1d = float(blend_position)
		elif blend_position is Vector2:
			pos_1d = (blend_position as Vector2).x
		bs1d.add_blend_point(node, pos_1d)
		_emit_changed(bs1d)
		return true
	elif parent is AnimationNodeBlendSpace2D:
		if not name.is_valid_int():
			push_error("BlendSpace children must have numeric names, got: " + name, true)
			return false
		
		var bs2d = parent as AnimationNodeBlendSpace2D
		var pos_2d: Vector2 = Vector2.ZERO
		if blend_position is Vector2:
			pos_2d = blend_position as Vector2
		elif blend_position is float or blend_position is int:
			pos_2d = Vector2(float(blend_position), 0.0)
		bs2d.add_blend_point(node, pos_2d)
		_emit_changed(bs2d)
		return true

		
	return false

func _ensure_unique_name_state(sm: AnimationNodeStateMachine, base_name: String) -> String:
	var test_name = base_name
	var counter = 1
	
	while sm.has_node(test_name):
		counter += 1
		test_name = base_name + str(counter)
		if counter > 1000:
			return base_name + "_" + str(Time.get_unix_time_from_system())
	
	return test_name

func _ensure_unique_name_blend(bt: AnimationNodeBlendTree, base_name: String) -> String:
	var test_name = base_name
	var counter = 1
	
	while is_instance_valid(bt.get_node(test_name)):
		counter += 1
		test_name = base_name + str(counter)
		if counter > 1000:
			return base_name + "_" + str(Time.get_unix_time_from_system())
	
	return test_name

func _emit_changed(node: AnimationNode) -> void:
	if node.has_method("emit_changed"):
		node.emit_changed()

func _extract_blend_connections(bt: AnimationNodeBlendTree, node_name: String) -> Array[Dictionary]:
	var connections: Array[Dictionary] = []
	# Placeholder for BlendTree connections
	return connections

func _restore_blend_connections(bt: AnimationNodeBlendTree, connections: Array[Dictionary], old_name: String, new_name: String) -> void:
	# Placeholder for restoring connections
	pass

func _collect_merge_transition_data(sm: AnimationNodeStateMachine, node_names: Array[String]) -> Dictionary:
	var internal: Array[Dictionary] = []
	var incoming: Array[Dictionary] = []
	var outgoing: Dictionary = {}
	
	var count = sm.get_transition_count()
	for i in range(count):
		var from = sm.get_transition_from(i)
		var to = sm.get_transition_to(i)
		var trans = sm.get_transition(i)
		
		var from_is_merged = from in node_names
		var to_is_merged = to in node_names
		
		if from_is_merged and to_is_merged:
			internal.append({"from": from, "to": to, "transition": trans})
		elif not from_is_merged and to_is_merged:
			incoming.append({"from": from, "to": to, "transition": trans})
		elif from_is_merged and not to_is_merged:
			if not outgoing.has(to):
				outgoing[to] = []
			outgoing[to].append({"from": from, "transition": trans})
	
	return {
		"internal": internal,
		"incoming": incoming,
		"outgoing": outgoing
	}

func _create_internal_merge_structure(new_sm: AnimationNodeStateMachine, internal_transitions: Array, incoming_transitions: Array, outgoing_transitions: Dictionary) -> void:
	# Add internal transitions
	for trans_data in internal_transitions:
		var new_transition = _copy_transition(trans_data["transition"])
		new_sm.add_transition(trans_data["from"], trans_data["to"], new_transition)
	
	# Group incoming transitions by target
	var incoming_by_target: Dictionary = {}
	for trans_data in incoming_transitions:
		var target_node = trans_data["to"]
		if not incoming_by_target.has(target_node):
			incoming_by_target[target_node] = []
		incoming_by_target[target_node].append(trans_data)
	
	# Create Start transitions
	for target_node in incoming_by_target.keys():
		var transitions_to_target = incoming_by_target[target_node] as Array
		var start_transition = _create_combined_transition(transitions_to_target)
		new_sm.add_transition("Start", target_node, start_transition)
	
	# Create End transitions
	for target_node in outgoing_transitions.keys():
		var transitions_to_target = outgoing_transitions[target_node] as Array
		for trans_data in transitions_to_target:
			var end_transition = _copy_transition(trans_data["transition"])
			new_sm.add_transition(trans_data["from"], "End", end_transition)

func _create_external_transitions_for_merge(sm: AnimationNodeStateMachine, merged_name: String, incoming_transitions: Array, outgoing_transitions: Dictionary) -> void:
	# Group incoming by source
	var grouped_incoming: Dictionary = {}
	for trans_data in incoming_transitions:
		var from_node = trans_data["from"]
		if not grouped_incoming.has(from_node):
			grouped_incoming[from_node] = []
		grouped_incoming[from_node].append(trans_data)
	
	# Create incoming transitions
	for from_node in grouped_incoming.keys():
		var transitions = grouped_incoming[from_node] as Array
		var transition = _create_combined_transition(transitions)
		sm.add_transition(from_node, merged_name, transition)
	
	# Create outgoing transitions
	for target_node in outgoing_transitions.keys():
		var transitions = outgoing_transitions[target_node] as Array
		var transition = _create_combined_transition(transitions)
		sm.add_transition(merged_name, target_node, transition)

func _create_combined_transition(transitions: Array) -> AnimationNodeStateMachineTransition:
	var template_transition = _copy_transition(transitions[0]["transition"])
	
	if transitions.size() > 1:
		var unique_conditions: Array[String] = []
		
		for trans_data in transitions:
			var transition = trans_data["transition"]
			var condition = transition.advance_condition
			var expression = transition.advance_expression
			
			var condition_text = condition if not condition.is_empty() else ("(" + expression + ")" if not expression.is_empty() else "")
			if not condition_text.is_empty() and condition_text not in unique_conditions:
				unique_conditions.append(condition_text)
		
		if not unique_conditions.is_empty():
			template_transition.advance_expression = " or ".join(unique_conditions)
			template_transition.advance_condition = ""
			template_transition.advance_mode = AnimationNodeStateMachineTransition.ADVANCE_MODE_ENABLED
	
	return template_transition

func _copy_transition(trans: AnimationNodeStateMachineTransition) -> AnimationNodeStateMachineTransition:
	var new_trans = AnimationNodeStateMachineTransition.new()
	new_trans.switch_mode = trans.switch_mode
	new_trans.advance_mode = trans.advance_mode
	new_trans.advance_condition = trans.advance_condition
	new_trans.advance_expression = trans.advance_expression
	new_trans.xfade_time = trans.xfade_time
	new_trans.priority = trans.priority
	new_trans.reset = trans.reset
	if trans.xfade_curve:
		new_trans.xfade_curve = trans.xfade_curve
	return new_trans
