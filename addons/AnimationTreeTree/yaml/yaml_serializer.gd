# spinalcord
# https://github.com/spinalcord/animation-tree-tree-godot
# 
# This file is part of animation-tree-tree-godot.
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public.
#
# NOTE: The output generated by this addon is not affected by this license.

class_name YamlSerializer
extends RefCounted

## YAML Serializer for Godot 4.x
## Converts objects and complex data structures to YAML format
## By spinalcord (github.com/spinalcord)

# Serialization state
var _visited_objects: Dictionary = {}
var _current_depth: int = 0

# Configuration
const MAX_DEPTH: int = 50
const INDENT_SIZE: int = 2

## Serialization options
class SerializeOptions extends RefCounted:
	## Maximum depth for nested structures
	var max_depth: int = MAX_DEPTH
	
	## Include only these properties (empty = include all)
	var include_properties: Array = []
	
	## Exclude these properties
	var exclude_properties: Array = []
	
	## Skip built-in properties (script, resource_path, etc.)
	var skip_builtin_properties: bool = true
	
	## Skip null values
	var skip_null_values: bool = false
	
	## Skip empty collections (arrays/dictionaries)
	var skip_empty_collections: bool = false
	
	## Pretty print multiline strings
	var pretty_multiline: bool = true

## Serialize any value to YAML string
func to_text(value: Variant, options: SerializeOptions = null) -> String:
	if options == null:
		options = SerializeOptions.new()
	
	_reset_state()
	
	var result = _serialize_value(value, 0, options)
	
	# Clean up leading newline for root objects
	if result.begins_with("\n"):
		result = result.substr(1)
	
	return result

## Serialize to file
func to_file(value: Variant, file_path: String, options: SerializeOptions = null) -> bool:
	var yaml_content = to_text(value, options)
	
	var file = FileAccess.open(file_path, FileAccess.WRITE)
	if not file:
		push_error("Could not write to file: " + file_path)
		return false
	
	file.store_string(yaml_content)
	file.close()
	return true

# ============================================================================
# Private Methods - Serialization
# ============================================================================

func _reset_state():
	_visited_objects.clear()
	_current_depth = 0

func _serialize_value(value: Variant, indent: int, options: SerializeOptions) -> String:
	# Depth check
	if indent > options.max_depth:
		return '"[Max Depth Exceeded]"'
	
	# Null check
	if value == null:
		return "null" if not options.skip_null_values else ""
	
	var value_type = typeof(value)
	
	match value_type:
		TYPE_BOOL:
			return "true" if value else "false"
		
		TYPE_INT, TYPE_FLOAT:
			return str(value)
		
		TYPE_STRING:
			return _serialize_string(value, indent, options)
		
		TYPE_ARRAY:
			return _serialize_array(value, indent, options)
		
		TYPE_DICTIONARY:
			return _serialize_dictionary(value, indent, options)
		
		TYPE_OBJECT:
			return _serialize_object(value, indent, options)
		
		TYPE_VECTOR2:
			return "Vector2(%s, %s)" % [value.x, value.y]
		
		TYPE_VECTOR3:
			return "Vector3(%s, %s, %s)" % [value.x, value.y, value.z]
		
		TYPE_VECTOR4:
			return "Vector4(%s, %s, %s, %s)" % [value.x, value.y, value.z, value.w]
		
		TYPE_COLOR:
			return _serialize_color(value)
		
		TYPE_RECT2:
			return "Rect2(%s, %s, %s, %s)" % [
				value.position.x, value.position.y,
				value.size.x, value.size.y
			]
		
		TYPE_VECTOR2I:
			return "Vector2i(%s, %s)" % [value.x, value.y]
		
		TYPE_VECTOR3I:
			return "Vector3i(%s, %s, %s)" % [value.x, value.y, value.z]
		
		TYPE_VECTOR4I:
			return "Vector4i(%s, %s, %s, %s)" % [value.x, value.y, value.z, value.w]
		
		TYPE_QUATERNION:
			return "Quaternion(%s, %s, %s, %s)" % [value.x, value.y, value.z, value.w]
		
		TYPE_TRANSFORM2D:
			return _serialize_transform2d(value)
		
		TYPE_TRANSFORM3D:
			return _serialize_transform3d(value)
	
	# Fallback for unsupported types
	return '"%s"' % str(value).replace('"', '\\"')

func _serialize_string(text: String, indent: int, options: SerializeOptions) -> String:
	# Empty string
	if text.is_empty():
		return '""'
	
	# Multiline string
	if options.pretty_multiline and ("\n" in text or text.length() > 80):
		return _serialize_multiline_string(text, indent)
	
	# String needs quoting
	if _needs_quoting(text):
		return '"' + _escape_string(text) + '"'
	
	return text

func _serialize_multiline_string(text: String, indent: int) -> String:
	# The parser expects base_indent + INDENT_SIZE indentation
	var indent_str = " ".repeat((indent + 1) * INDENT_SIZE)
	var lines = text.split("\n")
	
	var result = "|\n"
	for line in lines:
		result += indent_str + line + "\n"
	
	# Remove trailing newline that we added
	if result.ends_with("\n\n"):
		result = result.rstrip("\n") + "\n"
	
	return result.rstrip("\n")

func _serialize_array(arr: Array, indent: int, options: SerializeOptions) -> String:
	if arr.is_empty():
		return "[]" if not options.skip_empty_collections else ""
	
	var indent_str = " ".repeat(indent * INDENT_SIZE)
	var lines: Array[String] = []
	
	_current_depth += 1
	
	for item in arr:
		var serialized = _serialize_value(item, indent + 1, options)
		
		# Skip if empty and should skip empty values
		if serialized.is_empty() and (options.skip_null_values or options.skip_empty_collections):
			continue
		
		# Handle nested arrays, dictionaries AND objects
		if typeof(item) == TYPE_ARRAY or typeof(item) == TYPE_DICTIONARY or typeof(item) == TYPE_OBJECT:
			if serialized.begins_with("\n"):
				# For nested structures, inline the first item with the dash
				var item_lines = serialized.substr(1).split("\n")
				if item_lines.size() > 0 and not item_lines[0].is_empty():
					# Calculate base indentation that was used in serialization
					var base_indent = (indent + 1) * INDENT_SIZE
					
					# Put first line directly after dash
					var first_line = item_lines[0]
					var first_line_content = first_line.lstrip(" ")
					lines.append(indent_str + "- " + first_line_content)
					
					# Add remaining lines with adjusted indentation
					for i in range(1, item_lines.size()):
						if not item_lines[i].is_empty():
							# Count leading spaces in the original line
							var line = item_lines[i]
							var leading_spaces = len(line) - len(line.lstrip(" "))
							
							# Calculate relative indentation from base
							var relative_indent = leading_spaces - base_indent
							
							# New base is indent + 2 spaces (for the "- ")
							var new_indent = indent * INDENT_SIZE + 2 + relative_indent
							
							# Build the new line with correct indentation
							var line_content = line.lstrip(" ")
							lines.append(" ".repeat(new_indent) + line_content)
				else:
					# Empty nested structure
					lines.append(indent_str + "- " + serialized.strip_edges())
			else:
				lines.append(indent_str + "- " + serialized)
		else:
			lines.append(indent_str + "- " + serialized)
	
	_current_depth -= 1
	
	if lines.is_empty():
		return "[]" if not options.skip_empty_collections else ""
	
	return "\n" + "\n".join(lines)
	
func _serialize_dictionary(dict: Dictionary, indent: int, options: SerializeOptions) -> String:
	if dict.is_empty():
		return "{}" if not options.skip_empty_collections else ""
	
	var indent_str = " ".repeat(indent * INDENT_SIZE)
	var lines: Array[String] = []
	
	_current_depth += 1
	
	# Sort keys for consistent output
	var keys = dict.keys()
	#keys.sort()
	
	for key in keys:
		var key_str = str(key)
		
		# Apply property filters for dictionaries too
		if not options.include_properties.is_empty():
			if key_str not in options.include_properties:
				continue
		
		if key_str in options.exclude_properties:
			continue
		
		var value = dict[key]
		
		# Serialize value
		var serialized = _serialize_value(value, indent + 1, options)
		
		# Skip if empty and should skip empty values
		if serialized.is_empty() and (options.skip_null_values or options.skip_empty_collections):
			continue
		
		# Quote key if necessary (important for special keys like empty strings, whitespace, etc.)
		var formatted_key = _format_dict_key(key_str)
		
		# Handle nested structures
		if serialized.begins_with("\n"):
			lines.append(indent_str + formatted_key + ":" + serialized)
		else:
			lines.append(indent_str + formatted_key + ": " + serialized)
	
	_current_depth -= 1
	
	if lines.is_empty():
		return "{}" if not options.skip_empty_collections else ""
	
	return "\n" + "\n".join(lines)

# ============================================================================
# Helper method for dictionary keys
# ============================================================================

func _format_dict_key(key_str: String) -> String:
	# Keys need to be quoted if they could be misinterpreted by YAML parser
	if _needs_quoting_for_key(key_str):
		return '"' + _escape_string(key_str) + '"'
	return key_str

func _needs_quoting_for_key(key_str: String) -> bool:
	# Empty key must be quoted
	if key_str.is_empty():
		return true
	
	# Key that is only whitespace must be quoted
	if key_str.strip_edges().is_empty():
		return true
	
	# Use the general needs quoting logic for other cases
	return _needs_quoting(key_str)
	
func _serialize_object(obj: Object, indent: int, options: SerializeOptions) -> String:
	# Check for circular references
	var obj_id = obj.get_instance_id()
	if _visited_objects.has(obj_id):
		return '"[Circular Reference]"'
	
	_visited_objects[obj_id] = true
	
	# Get all properties
	var properties = _get_object_properties(obj, options)
	
	# Convert to dictionary format
	var data = {}
	for prop in properties:
		var value = obj.get(prop)
		data[prop] = value
	
	var result = _serialize_dictionary(data, indent, options)
	
	# Clean up visited tracking for this object
	_visited_objects.erase(obj_id)
	
	return result

func _serialize_color(color: Color) -> String:
	# Use hex format if alpha is 1.0
	if color.a == 1.0:
		return '"#%s"' % color.to_html(false)
	else:
		return "Color(%s, %s, %s, %s)" % [color.r, color.g, color.b, color.a]

func _serialize_transform2d(transform: Transform2D) -> String:
	return "Transform2D(%s, %s, %s)" % [
		_serialize_vector2(transform.x),
		_serialize_vector2(transform.y),
		_serialize_vector2(transform.origin)
	]

func _serialize_transform3d(transform: Transform3D) -> String:
	return "Transform3D(%s, %s, %s, %s)" % [
		_serialize_vector3(transform.basis.x),
		_serialize_vector3(transform.basis.y),
		_serialize_vector3(transform.basis.z),
		_serialize_vector3(transform.origin)
	]

func _serialize_vector2(vec: Vector2) -> String:
	return "Vector2(%s, %s)" % [vec.x, vec.y]

func _serialize_vector3(vec: Vector3) -> String:
	return "Vector3(%s, %s, %s)" % [vec.x, vec.y, vec.z]

# ============================================================================
# Private Methods - Object Introspection
# ============================================================================

func _get_object_properties(obj: Object, options: SerializeOptions) -> Array[String]:
	var properties: Array[String] = []
	
	# Use property list to get all exported properties
	var property_list = obj.get_property_list()
	
	for prop_info in property_list:
		var prop_name = prop_info["name"]
		
		# Skip built-in properties if configured
		if options.skip_builtin_properties:
			if _is_builtin_property(prop_name):
				continue
		
		# Handle include filter
		if not options.include_properties.is_empty():
			if prop_name not in options.include_properties:
				continue
		
		# Handle exclude filter
		if prop_name in options.exclude_properties:
			continue
		
		# Only include exported properties or properties with PROPERTY_USAGE_STORAGE
		var usage = prop_info["usage"]
		if usage & PROPERTY_USAGE_STORAGE or usage & PROPERTY_USAGE_SCRIPT_VARIABLE:
			properties.append(prop_name)
	
	return properties

func _is_builtin_property(prop_name: String) -> bool:
	# List of common built-in properties to skip
	var builtin_props = [
		"script",
		"resource_path",
		"resource_name",
		"resource_local_to_scene",
		"resource_scene_unique_id",
		"Script Variables",
		"RefCounted",
		"Resource"
	]
	
	if prop_name in builtin_props:
		return true
	
	# Skip internal properties (starting with underscore)
	if prop_name.begins_with("_"):
		return true
	
	return false

# ============================================================================
# Helper Methods
# ============================================================================

func _needs_quoting(text: String) -> bool:
	# Check if string needs to be quoted
	if text.is_empty():
		return true
	
	# Check for special YAML characters
	var special_chars = [":", "#", "[", "]", "{", "}", ",", "&", "*", "?", "|", "-", "<", ">", "=", "!", "%", "@", "`"]
	for char in special_chars:
		if char in text:
			return true
	
	# Check for YAML keywords
	var keywords = ["true", "false", "null", "yes", "no", "on", "off", "~"]
	if text.to_lower() in keywords:
		return true
	
	# Check if it looks like a number
	if text.is_valid_float() or text.is_valid_int():
		return true
	
	# Check for leading/trailing whitespace
	if text != text.strip_edges():
		return true
	
	return false

func _escape_string(text: String) -> String:
	var result = text
	result = result.replace("\\", "\\\\")
	result = result.replace('"', '\\"')
	result = result.replace("\n", "\\n")
	result = result.replace("\t", "\\t")
	result = result.replace("\r", "\\r")
	return result
