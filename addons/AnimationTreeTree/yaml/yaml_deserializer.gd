# spinalcord
# https://github.com/spinalcord/animation-tree-tree-godot
# 
# This file is part of animation-tree-tree-godot.
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public.
#
# NOTE: The output generated by this addon is not affected by this license.

class_name YamlDeserializer
extends RefCounted

## YAML Parser for Godot 4.x
## Supports YAML 1.2 subset with Godot-specific types
## By spinalcord (github.com/spinalcord)

# Parser state
var _line_number: int = 0
var _current_indent: int = 0
var _anchors: Dictionary = {}
var _errors: Array[String] = []

# Configuration
const INDENT_SIZE: int = 2
const MAX_DEPTH: int = 100

## Parse YAML string and return dictionary or null on error
func from_text(yaml_content: String) -> Variant:
	_reset_state()
	if yaml_content.is_empty():
		return {}
	# Normalize line endings and convert tabs to spaces
	yaml_content = _normalize_content(yaml_content)
	
	var lines = yaml_content.split("\n")
	
	# Validate indentation before parsing
	if not _validate_indentation(lines):
		push_error("YAML parsing failed: Invalid indentation")
		return null
	
	var result = _parse_lines(lines, 0, 0)
	
	if _errors.size() > 0:
		push_error("YAML parsing failed: " + str(_errors))
		return null
	
	return result


## Parse YAML file and return dictionary or null on error
func from_file(file_path: String) -> Variant:
	if not FileAccess.file_exists(file_path):
		push_error("YAML file not found: " + file_path)
		return null
	
	var file = FileAccess.open(file_path, FileAccess.READ)
	if not file:
		push_error("Could not open YAML file: " + file_path)
		return null
	
	var content = file.get_as_text()
	file.close()
	
	return from_text(content)


# ============================================================================
# Private Methods - Validation
# ============================================================================

func _validate_indentation(lines: Array) -> bool:
	var indent_stack: Array[int] = []
	var last_indent = -1
	
	for i in range(lines.size()):
		var line = lines[i]
		_line_number = i + 1
		
		# Skip empty lines and comments
		if _is_empty_or_comment(line):
			continue
		
		var indent = _get_indent(line)
		var trimmed = line.strip_edges()
		
		# Check if indentation is multiple of INDENT_SIZE
		if indent % INDENT_SIZE != 0:
			_add_error("Invalid indentation: must be multiple of %d spaces" % INDENT_SIZE)
			return false
		
		# Check for mixed spaces and tabs (should not happen after normalization, but safety check)
		for j in range(indent):
			if line[j] != " ":
				_add_error("Invalid indentation: contains non-space characters")
				return false
		
		# Skip first line for indent consistency check
		if last_indent == -1:
			last_indent = indent
			if indent > 0:
				indent_stack.append(indent)
			continue
		
		# Handle indentation levels
		if indent > last_indent:
			# Deeper level - must be exactly INDENT_SIZE more
			if indent - last_indent != INDENT_SIZE:
				_add_error("Bad indentation: expected %d spaces, got %d" % [last_indent + INDENT_SIZE, indent])
				return false
			indent_stack.append(last_indent)
		elif indent < last_indent:
			# Shallower level - must match a previous level
			var found_level = false
			while indent_stack.size() > 0:
				var prev_indent = indent_stack.pop_back()
				if prev_indent == indent:
					found_level = true
					break
				elif prev_indent < indent:
					# We went too far back
					break
			
			if not found_level and indent != 0:
				_add_error("Bad indentation: %d spaces does not match any previous indentation level" % indent)
				return false
		# Same level is always OK
		
		last_indent = indent
	
	return true

# ============================================================================
# Private Methods - Parsing
# ============================================================================

func _reset_state():
	_line_number = 0
	_current_indent = 0
	_anchors = {}
	_errors = []

func _normalize_content(content: String) -> String:
	# Convert tabs to spaces (4 spaces per tab for compatibility)
	content = content.replace("\t", "    ")
	
	# Normalize line endings
	content = content.replace("\r\n", "\n")
	content = content.replace("\r", "\n")
	
	return content

func _parse_lines(lines: Array, start_index: int, base_indent: int, depth: int = 0) -> Variant:
	if depth > MAX_DEPTH:
		_add_error("Maximum nesting depth exceeded")
		return null
	
	var result = {}
	var i = start_index
	
	# Find actual base indent from first non-empty line if base_indent is 0
	if base_indent == 0 and start_index == 0:
		for line_idx in range(start_index, lines.size()):
			if not _is_empty_or_comment(lines[line_idx]):
				base_indent = _get_indent(lines[line_idx])
				break
	
	while i < lines.size():
		_line_number = i + 1
		var line = lines[i]
		
		# Skip empty lines and comments
		if _is_empty_or_comment(line):
			i += 1
			continue
		
		var indent = _get_indent(line)
		
		# End of current block
		if indent < base_indent:
			break
		
		# Skip if not at current level
		if indent > base_indent:
			i += 1
			continue
		
		var trimmed = line.strip_edges()
		
		# Handle list items
		if trimmed.begins_with("- "):
			var array_result = _parse_array(lines, i, base_indent, depth)
			if array_result.has("error"):
				return null
			return array_result.value
		
		# Handle key-value pairs
		if ":" in trimmed:
			var kv = _parse_key_value(lines, i, base_indent, depth)
			if kv.has("error"):
				return null
			
			result[kv.key] = kv.value
			i = kv.next_index
			continue
		
		i += 1
	
	return result


func _parse_key_value(lines: Array, line_index: int, base_indent: int, depth: int) -> Dictionary:
	var line = lines[line_index]
	var trimmed = line.strip_edges()
	
	# Remove inline comments
	var comment_pos = _find_comment_position(trimmed)
	if comment_pos != -1:
		trimmed = trimmed.substr(0, comment_pos).strip_edges()
	
	var colon_pos = trimmed.find(":")
	if colon_pos == -1:
		_add_error("Invalid key-value format")
		return {"error": true}
	
	var key_str = trimmed.substr(0, colon_pos).strip_edges()
	var value_part = trimmed.substr(colon_pos + 1).strip_edges()
	
	# Parse the key to handle quoted keys properly
	var key = _parse_key(key_str)
	
	# Handle anchor definition (&name) - anchors come after the colon
	var anchor_name = ""
	if value_part.begins_with("&"):
		# Extract anchor name
		var space_pos = value_part.find(" ")
		if space_pos != -1:
			anchor_name = value_part.substr(1, space_pos - 1).strip_edges()
			value_part = value_part.substr(space_pos + 1).strip_edges()
		else:
			# Anchor with no inline value
			anchor_name = value_part.substr(1).strip_edges()
			value_part = ""
	
	var result = {"key": key, "next_index": line_index + 1}
	
	# Empty value or null
	if value_part.is_empty():
		# Check if next line is nested (skip comments)
		var next_valid_index = line_index + 1
		while next_valid_index < lines.size() and _is_empty_or_comment(lines[next_valid_index]):
			next_valid_index += 1
		
		if next_valid_index < lines.size():
			var next_line = lines[next_valid_index]
			var next_indent = _get_indent(next_line)
			if next_indent > base_indent:
				# Nested structure
				var next_trimmed = next_line.strip_edges()
				if next_trimmed.begins_with("- "):
					# Nested array
					var array_result = _parse_array(lines, next_valid_index, next_indent, depth + 1)
					if array_result.has("error"):
						return {"error": true}
					result.value = array_result.value
					result.next_index = array_result.next_index
					
					# Store anchor if defined
					if not anchor_name.is_empty():
						_anchors[anchor_name] = result.value
					
					return result
				else:
					# Nested dictionary
					var dict_value = _parse_lines(lines, next_valid_index, next_indent, depth + 1)
					result.value = dict_value
					
					# Store anchor if defined
					if not anchor_name.is_empty():
						_anchors[anchor_name] = result.value
					
					# Find next line at current level
					var next_idx = next_valid_index
					while next_idx < lines.size():
						if not _is_empty_or_comment(lines[next_idx]):
							if _get_indent(lines[next_idx]) <= base_indent:
								break
						next_idx += 1
					result.next_index = next_idx
					return result
		
		result.value = null
		return result
	
	# Handle alias reference (*name)
	if value_part.begins_with("*"):
		var alias_name = value_part.substr(1).strip_edges()
		if _anchors.has(alias_name):
			result.value = _anchors[alias_name]
		else:
			_add_error("Undefined alias: " + alias_name)
			return {"error": true}
		return result
	
	# Handle multiline strings
	if value_part == "|" or value_part == ">":
		var multiline_result = _parse_multiline_string(lines, line_index, base_indent, value_part == ">")
		if multiline_result.has("error"):
			return {"error": true}
		result.value = multiline_result.value
		result.next_index = multiline_result.next_index
		
		# Store anchor if defined
		if not anchor_name.is_empty():
			_anchors[anchor_name] = result.value
		
		return result
	
	# Inline array or dictionary
	if value_part.begins_with("[") or value_part.begins_with("{"):
		result.value = _parse_inline_collection(value_part)
		if result.value == null:
			return {"error": true}
		
		# Store anchor if defined
		if not anchor_name.is_empty():
			_anchors[anchor_name] = result.value
		
		return result
	
	# Parse value
	result.value = _parse_value(value_part)
	
	# Store anchor if defined
	if not anchor_name.is_empty():
		_anchors[anchor_name] = result.value
	
	return result

# ============================================================================
# New helper function for parsing keys
# ============================================================================

func _parse_key(key_str: String) -> String:
	# If the key is quoted, parse it as a value to remove quotes and unescape
	if (key_str.begins_with('"') and key_str.ends_with('"')) or \
	   (key_str.begins_with("'") and key_str.ends_with("'")):
		var unquoted = key_str.substr(1, key_str.length() - 2)
		return _unescape_string(unquoted)
	
	# Otherwise, use the key as-is
	return key_str

func _parse_array(lines: Array, start_index: int, base_indent: int, depth: int) -> Dictionary:
	if depth > MAX_DEPTH:
		_add_error("Maximum nesting depth exceeded")
		return {"error": true}
	
	var result = []
	var i = start_index
	
	while i < lines.size():
		var line = lines[i]
		
		if _is_empty_or_comment(line):
			i += 1
			continue
		
		var indent = _get_indent(line)
		
		if indent < base_indent:
			break
		
		if indent > base_indent:
			i += 1
			continue
		
		var trimmed = line.strip_edges()
		
		if not trimmed.begins_with("- "):
			break
		
		var item_content = trimmed.substr(2).strip_edges()
		
		# Empty list item or nested structure
		if item_content.is_empty():
			if i + 1 < lines.size():
				var next_line = lines[i + 1]
				if not _is_empty_or_comment(next_line):
					var next_indent = _get_indent(next_line)
					if next_indent > indent:
						# Nested structure
						var nested = _parse_lines(lines, i + 1, next_indent, depth + 1)
						result.append(nested)
						# Skip processed lines
						i += 1
						while i < lines.size():
							if not _is_empty_or_comment(lines[i]):
								if _get_indent(lines[i]) <= indent:
									break
							i += 1
						continue
			result.append(null)
			i += 1
			continue
		
		# Inline collection
		if item_content.begins_with("[") or item_content.begins_with("{"):
			var value = _parse_inline_collection(item_content)
			if value == null:
				return {"error": true}
			result.append(value)
			i += 1
			continue
		
		# Check for nested dictionary (multi-line)
		if ":" in item_content:
			# Check if there are more properties on following lines
			var dict_result = {}
			var kv = _parse_key_value_simple(item_content)
			if kv.has("error"):
				return {"error": true}
			dict_result[kv.key] = kv.value
			
			# Check for additional properties at deeper indent levels
			var next_idx = i + 1
			var item_indent = indent + 2  # Expected indent for dictionary properties
			
			while next_idx < lines.size():
				if _is_empty_or_comment(lines[next_idx]):
					next_idx += 1
					continue
				
				var next_indent = _get_indent(lines[next_idx])
				var next_trimmed = lines[next_idx].strip_edges()
				
				# Property at correct indent level
				if next_indent == item_indent and not next_trimmed.begins_with("- "):
					if ":" in next_trimmed:
						# Check if this is a nested array
						var prop_kv = _parse_key_value_simple(next_trimmed)
						if not prop_kv.has("error"):
							# Check if next line is an array
							var peek_idx = next_idx + 1
							while peek_idx < lines.size() and _is_empty_or_comment(lines[peek_idx]):
								peek_idx += 1
							
							if peek_idx < lines.size():
								var peek_line = lines[peek_idx]
								var peek_indent = _get_indent(peek_line)
								var peek_trimmed = peek_line.strip_edges()
								
								# Next line is an array item at deeper level
								if peek_trimmed.begins_with("- ") and peek_indent > item_indent:
									var nested_array = _parse_array(lines, peek_idx, peek_indent, depth + 1)
									if nested_array.has("error"):
										return {"error": true}
									dict_result[prop_kv.key] = nested_array.value
									next_idx = nested_array.next_index
									continue
								# Next line is a nested dictionary
								elif peek_indent > item_indent and ":" in peek_trimmed:
									var nested_dict = _parse_lines(lines, peek_idx, peek_indent, depth + 1)
									dict_result[prop_kv.key] = nested_dict
									# Skip to next item
									next_idx = peek_idx + 1
									while next_idx < lines.size():
										if not _is_empty_or_comment(lines[next_idx]):
											if _get_indent(lines[next_idx]) <= item_indent:
												break
										next_idx += 1
									continue
							
							# Simple value
							dict_result[prop_kv.key] = prop_kv.value
							next_idx += 1
							continue
				
				# Different indent - end of this dictionary item
				if next_indent <= indent:
					break
				
				next_idx += 1
			
			result.append(dict_result)
			i = next_idx
			continue
		
		# Simple value
		result.append(_parse_value(item_content))
		i += 1
	
	return {"value": result, "next_index": i}

func _parse_key_value_simple(line: String) -> Dictionary:
	var colon_pos = line.find(":")
	if colon_pos == -1:
		_add_error("Invalid key-value format")
		return {"error": true}
	
	var key = line.substr(0, colon_pos).strip_edges()
	var value_part = line.substr(colon_pos + 1).strip_edges()
	
	return {
		"key": key,
		"value": _parse_value(value_part) if not value_part.is_empty() else null
	}

func _parse_multiline_string(lines: Array, start_index: int, base_indent: int, fold: bool) -> Dictionary:
	var content_lines: Array[String] = []
	var i = start_index + 1
	
	while i < lines.size():
		var line = lines[i]
		
		if _is_empty_or_comment(line):
			if fold:
				content_lines.append("")
			else:
				content_lines.append(line)
			i += 1
			continue
		
		var indent = _get_indent(line)
		
		if indent <= base_indent:
			break
		
		content_lines.append(line.substr(base_indent + INDENT_SIZE))
		i += 1
	
	var result: String
	if fold:
		# Folded style - join lines with spaces
		var non_empty_lines: Array[String] = []
		for line in content_lines:
			if not line.strip_edges().is_empty():
				non_empty_lines.append(line.strip_edges())
		result = " ".join(non_empty_lines) + "\n"
	else:
		# Literal style - preserve line breaks
		result = "\n".join(content_lines) + "\n"
	
	return {"value": result, "next_index": i}

func _parse_inline_collection(text: String) -> Variant:
	text = text.strip_edges()
	
	# Inline array
	if text.begins_with("[") and text.ends_with("]"):
		var content = text.substr(1, text.length() - 2).strip_edges()
		if content.is_empty():
			return []
		
		var items = _split_collection_items(content)
		var result = []
		for item in items:
			result.append(_parse_value(item.strip_edges()))
		return result
	
	# Inline dictionary
	if text.begins_with("{") and text.ends_with("}"):
		var content = text.substr(1, text.length() - 2).strip_edges()
		if content.is_empty():
			return {}
		
		var items = _split_collection_items(content)
		var result = {}
		for item in items:
			if ":" not in item:
				_add_error("Invalid dictionary item: " + item)
				return null
			var parts = item.split(":", true, 1)
			var key = parts[0].strip_edges()
			var value = parts[1].strip_edges() if parts.size() > 1 else ""
			result[key] = _parse_value(value)
		return result
	
	_add_error("Invalid inline collection: " + text)
	return null

func _split_collection_items(content: String) -> Array[String]:
	var items: Array[String] = []
	var current_item = ""
	var depth = 0
	var in_quotes = false
	var quote_char = ""
	
	for i in content.length():
		var c = content[i]
		
		if c in ['"', "'"]:
			if not in_quotes:
				in_quotes = true
				quote_char = c
			elif c == quote_char and (i == 0 or content[i - 1] != "\\"):
				in_quotes = false
				quote_char = ""
		
		if not in_quotes:
			if c in ["[", "{"]:
				depth += 1
			elif c in ["]", "}"]:
				depth -= 1
			elif c == "," and depth == 0:
				items.append(current_item)
				current_item = ""
				continue
		
		current_item += c
	
	if not current_item.is_empty():
		items.append(current_item)
	
	return items

func _parse_value(text: String) -> Variant:
	text = text.strip_edges()
	
	if text.is_empty():
		return null
	
	# Remove inline comments
	var comment_pos = _find_comment_position(text)
	if comment_pos != -1:
		text = text.substr(0, comment_pos).strip_edges()
	
	# Null values
	if text in ["null", "~"]:
		return null
	
	# Boolean values
	if text.to_lower() in ["true", "yes", "on"]:
		return true
	if text.to_lower() in ["false", "no", "off"]:
		return false
	
	# Quoted strings
	if (text.begins_with('"') and text.ends_with('"')) or \
	   (text.begins_with("'") and text.ends_with("'")):
		var unquoted = text.substr(1, text.length() - 2)
		# Check for hex color
		if unquoted.begins_with("#") and unquoted.length() in [7, 9]:
			return Color(unquoted)
		return _unescape_string(unquoted)
	
	# Godot types
	var godot_value = _parse_godot_type(text)
	if godot_value != null:
		return godot_value
	
	# Numbers
	if text.is_valid_float():
		if "." in text or "e" in text.to_lower():
			return text.to_float()
		else:
			return text.to_int()
	
	# Hexadecimal
	if text.begins_with("0x") or text.begins_with("0X"):
		return text.hex_to_int()
	
	# String (unquoted)
	return text

func _parse_godot_type(text: String) -> Variant:
	# Vector2
	if text.begins_with("Vector2(") and text.ends_with(")"):
		var content = text.substr(8, text.length() - 9)
		var parts = content.split(",")
		if parts.size() == 2:
			return Vector2(parts[0].to_float(), parts[1].to_float())
	
	# Vector3
	if text.begins_with("Vector3(") and text.ends_with(")"):
		var content = text.substr(8, text.length() - 9)
		var parts = content.split(",")
		if parts.size() == 3:
			return Vector3(parts[0].to_float(), parts[1].to_float(), parts[2].to_float())
	
	# Color
	if text.begins_with("Color(") and text.ends_with(")"):
		var content = text.substr(6, text.length() - 7)
		var parts = content.split(",")
		if parts.size() == 3:
			return Color(parts[0].to_float(), parts[1].to_float(), parts[2].to_float())
		elif parts.size() == 4:
			return Color(parts[0].to_float(), parts[1].to_float(), parts[2].to_float(), parts[3].to_float())
	
	# Hex color
	if text.begins_with("#"):
		return Color(text)
	
	# Rect2
	if text.begins_with("Rect2(") and text.ends_with(")"):
		var content = text.substr(6, text.length() - 7)
		var parts = content.split(",")
		if parts.size() == 4:
			return Rect2(parts[0].to_float(), parts[1].to_float(), 
						parts[2].to_float(), parts[3].to_float())
	
	return null

func _unescape_string(text: String) -> String:
	var result = ""
	var i = 0
	while i < text.length():
		if text[i] == "\\" and i + 1 < text.length():
			var next_char = text[i + 1]
			match next_char:
				"n":
					result += "\n"
					i += 2
				"t":
					result += "\t"
					i += 2
				"r":
					result += "\r"
					i += 2
				"\"":
					result += "\""
					i += 2
				"'":
					result += "'"
					i += 2
				"\\":
					result += "\\"
					i += 2
				_:
					result += text[i]
					i += 1
		else:
			result += text[i]
			i += 1
	return result

# ============================================================================
# Private Methods - Serialization
# ============================================================================

func _serialize_value(value: Variant, indent: int) -> String:
	var indent_str = "  ".repeat(indent)
	
	if value == null:
		return "null"
	
	match typeof(value):
		TYPE_BOOL:
			return "true" if value else "false"
		
		TYPE_INT, TYPE_FLOAT:
			return str(value)
		
		TYPE_STRING:
			if "\n" in value or value.length() > 60:
				return _serialize_multiline_string(value, indent)
			elif ":" in value or value.begins_with("#") or value.begins_with("@"):
				return '"' + value.replace('"', '\\"') + '"'
			else:
				return value
		
		TYPE_ARRAY:
			if value.is_empty():
				return "[]"
			
			var lines: Array[String] = []
			for item in value:
				if typeof(item) == TYPE_DICTIONARY or typeof(item) == TYPE_ARRAY:
					var serialized = _serialize_value(item, indent + 1)
					lines.append(indent_str + "- " + serialized.strip_edges())
				else:
					lines.append(indent_str + "- " + _serialize_value(item, 0))
			return "\n" + "\n".join(lines)
		
		TYPE_DICTIONARY:
			if value.is_empty():
				return "{}"
			
			var lines: Array[String] = []
			for key in value:
				var val = value[key]
				if typeof(val) == TYPE_DICTIONARY or typeof(val) == TYPE_ARRAY:
					var serialized = _serialize_value(val, indent + 1)
					lines.append(indent_str + str(key) + ":" + serialized)
				else:
					lines.append(indent_str + str(key) + ": " + _serialize_value(val, 0))
			return "\n" + "\n".join(lines)
		
		TYPE_VECTOR2:
			return "Vector2(%s, %s)" % [value.x, value.y]
		
		TYPE_VECTOR3:
			return "Vector3(%s, %s, %s)" % [value.x, value.y, value.z]
		
		TYPE_COLOR:
			return "Color(%s, %s, %s, %s)" % [value.r, value.g, value.b, value.a]
		
		TYPE_RECT2:
			return "Rect2(%s, %s, %s, %s)" % [value.position.x, value.position.y, 
											   value.size.x, value.size.y]
	
	return str(value)

func _serialize_multiline_string(text: String, indent: int) -> String:
	var indent_str = "  ".repeat(indent + 1)
	var lines = text.split("\n")
	var result = "|\n"
	for line in lines:
		result += indent_str + line + "\n"
	return result

# ============================================================================
# Helper Methods
# ============================================================================

func _is_empty_or_comment(line: String) -> bool:
	var trimmed = line.strip_edges()
	return trimmed.is_empty() or trimmed.begins_with("#")

func _get_indent(line: String) -> int:
	var indent = 0
	for c in line:
		if c == " ":
			indent += 1
		else:
			break
	return indent

func _find_comment_position(text: String) -> int:
	var in_quotes = false
	var quote_char = ""
	
	for i in text.length():
		var c = text[i]
		
		if c in ['"', "'"]:
			if not in_quotes:
				in_quotes = true
				quote_char = c
			elif c == quote_char and (i == 0 or text[i - 1] != "\\"):
				in_quotes = false
				quote_char = ""
		
		if not in_quotes and c == "#":
			return i
	
	return -1

func _add_error(message: String):
	_errors.append("Line %d: %s" % [_line_number, message])
