# spinalcord
# https://github.com/spinalcord/animation-tree-tree-godot
# 
# This file is part of animation-tree-tree-godot.
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public.
#
# NOTE: The output generated by this addon is not affected by this license.

class_name FeedbackDialog
extends RefCounted

signal dialog_result(result: bool)
signal text_result(result: String)

func show_confirmation(message: String, title: String, add_cancel_button: bool = true) -> bool:
	# Create AcceptDialog instance
	var dialog = AcceptDialog.new()
	dialog.title = title
	dialog.dialog_text = message
	
	# Add cancel button if requested
	if add_cancel_button:
		dialog.add_cancel_button("Cancel")
	
	# Add dialog to scene tree (required for editor plugins)
	EditorInterface.get_base_control().add_child(dialog)
	
	TreeDebug.msg("Showing dialog: " + title)
	
	# Connect signals to emit our own signal with one-shot to prevent multiple emissions
	dialog.confirmed.connect(func(): 
		dialog_result.emit(true)
	, CONNECT_ONE_SHOT)
	
	dialog.canceled.connect(func(): 
		dialog_result.emit(false)
	, CONNECT_ONE_SHOT)
	
	# Center and show dialog
	dialog.popup_centered()
	
	# Wait for our custom signal
	var result = await dialog_result
	
	# Hide dialog first to prevent exclusive window issues
	dialog.hide()
	
	# Use call_deferred for safe cleanup after signal processing is complete
	dialog.call_deferred("queue_free")
	
	return result

func show_info(message: String, title: String) -> void:
	# Create AcceptDialog instance - no cancel button for info
	var dialog = AcceptDialog.new()
	dialog.title = title
	dialog.dialog_text = message
	
	# Add dialog to scene tree (required for editor plugins)
	EditorInterface.get_base_control().add_child(dialog)
	
	# Debug callback if provided
	TreeDebug.msg("Showing info: " + title)
	
	# Connect only confirmed signal for info dialog
	dialog.confirmed.connect(func(): 
		dialog_result.emit(true)
	, CONNECT_ONE_SHOT)
	
	# Center and show dialog
	dialog.popup_centered()
	
	# Wait for user to close
	await dialog_result
	
	# Hide dialog first to prevent exclusive window issues
	dialog.hide()
	
	# Use call_deferred for safe cleanup after signal processing is complete
	dialog.call_deferred("queue_free")

signal pick_result(result: String)

func show_pick(message: String, title: String, options: Dictionary[String, bool]) -> String:
	# Validate that only one option is set to true
	var true_count = 0
	for value in options.values():
		if value:
			true_count += 1
	
	if true_count > 1:
		push_error("show_pick: Multiple default values set to true. Only one option can be selected by default.")
		return ""
	
	# Create AcceptDialog instance
	var dialog = AcceptDialog.new()
	dialog.title = title
	dialog.dialog_text = ""  # Clear default text to avoid overlap
	
	# Add cancel button
	dialog.add_cancel_button("Cancel")
	
	# Create VBoxContainer for content
	var main_container = VBoxContainer.new()
	
	# Add message label
	var message_label = Label.new()
	message_label.text = message
	main_container.add_child(message_label)
	
	# Add spacing
	var spacer = Control.new()
	spacer.custom_minimum_size = Vector2(0, 10)
	main_container.add_child(spacer)
	
	# Create ScrollContainer for radio buttons
	var scroll_container = ScrollContainer.new()
	scroll_container.custom_minimum_size = Vector2(300, 200)
	scroll_container.size_flags_vertical = Control.SIZE_EXPAND_FILL
	scroll_container.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	
	# Create VBoxContainer inside ScrollContainer
	var radio_container = VBoxContainer.new()
	radio_container.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	
	# Store radio button references with their IDs
	var radio_nodes: Dictionary[String, CheckBox] = {}
	var first_option: String = ""
	
	# Create radio buttons from input dictionary
	for option_id in options.keys():
		var radio = CheckBox.new()
		radio.text = option_id.to_pascal_case()
		radio.toggle_mode = true
		radio.button_pressed = options[option_id]
		
		# Store first option for default selection
		if first_option.is_empty():
			first_option = option_id
		
		# Connect to ensure only one can be selected
		radio.toggled.connect(func(pressed: bool):
			if pressed:
				# Uncheck all other radio buttons
				for other_id in radio_nodes.keys():
					if other_id != option_id:
						radio_nodes[other_id].button_pressed = false
		)
		
		radio_container.add_child(radio)
		radio_nodes[option_id] = radio
	
	# Add radio container to scroll container
	scroll_container.add_child(radio_container)
	
	# Add scroll container to main container
	main_container.add_child(scroll_container)
	
	# Add container to dialog
	dialog.add_child(main_container)
	
	# Add dialog to scene tree (required for editor plugins)
	EditorInterface.get_base_control().add_child(dialog)
	
	TreeDebug.msg("Showing pick: " + title)
	
	# Connect signals with one-shot to prevent multiple emissions
	dialog.confirmed.connect(func():
		# Find selected option
		var selected: String = ""
		for option_id in radio_nodes.keys():
			if radio_nodes[option_id].button_pressed:
				selected = option_id
				break
		pick_result.emit(selected)
	, CONNECT_ONE_SHOT)
	
	dialog.canceled.connect(func():
		# Return empty string on cancel
		pick_result.emit("")
	, CONNECT_ONE_SHOT)
	
	# Center and show dialog
	dialog.popup_centered()
	
	# Wait for our custom signal
	var result = await pick_result
	
	# Hide dialog first to prevent exclusive window issues
	dialog.hide()
	
	# Use call_deferred for safe cleanup after signal processing is complete
	dialog.call_deferred("queue_free")
	
	return result
	
signal decisions_result(result: Dictionary)

func show_decisions(message: String, title: String, checkboxes: Dictionary[String, bool]) -> Dictionary[String, bool]:
	# Create AcceptDialog instance
	var dialog = AcceptDialog.new()
	dialog.title = title
	dialog.dialog_text = ""  # Clear default text to avoid overlap
	
	# Add cancel button
	dialog.add_cancel_button("Cancel")
	
	# Create VBoxContainer for content
	var main_container = VBoxContainer.new()
	
	# Add message label
	var message_label = Label.new()
	message_label.text = message
	main_container.add_child(message_label)
	
	# Add spacing
	var spacer = Control.new()
	spacer.custom_minimum_size = Vector2(0, 10)
	main_container.add_child(spacer)
	
	# Create ScrollContainer for checkboxes
	var scroll_container = ScrollContainer.new()
	scroll_container.custom_minimum_size = Vector2(300, 200)
	scroll_container.size_flags_vertical = Control.SIZE_EXPAND_FILL
	scroll_container.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	
	# Create VBoxContainer inside ScrollContainer
	var checkbox_container = VBoxContainer.new()
	checkbox_container.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	
	# Store checkbox references with their IDs
	var checkbox_nodes: Dictionary[String, CheckBox] = {}
	
	# Create checkboxes from input dictionary
	for checkbox_id in checkboxes.keys():
		var checkbox = CheckBox.new()
		checkbox.text = checkbox_id.to_pascal_case()
		checkbox.button_pressed = checkboxes[checkbox_id]
		checkbox_container.add_child(checkbox)
		checkbox_nodes[checkbox_id] = checkbox
	
	# Add checkbox container to scroll container
	scroll_container.add_child(checkbox_container)
	
	# Add scroll container to main container
	main_container.add_child(scroll_container)
	
	# Add container to dialog
	dialog.add_child(main_container)
	
	# Add dialog to scene tree (required for editor plugins)
	EditorInterface.get_base_control().add_child(dialog)
	
	TreeDebug.msg("Showing decisions: " + title)
	
	# Connect signals with one-shot to prevent multiple emissions
	dialog.confirmed.connect(func():
		# Collect checkbox states
		var result: Dictionary[String, bool] = {}
		for checkbox_id in checkbox_nodes.keys():
			result[checkbox_id] = checkbox_nodes[checkbox_id].button_pressed
		decisions_result.emit(result)
	, CONNECT_ONE_SHOT)
	
	dialog.canceled.connect(func():
		# Return empty dictionary on cancel
		var empty_result: Dictionary[String, bool] = {}
		decisions_result.emit(empty_result)
	, CONNECT_ONE_SHOT)
	
	# Center and show dialog
	dialog.popup_centered()
	
	# Wait for our custom signal
	var result = await decisions_result
	
	# Hide dialog first to prevent exclusive window issues
	dialog.hide()
	
	# Use call_deferred for safe cleanup after signal processing is complete
	dialog.call_deferred("queue_free")
	
	return result

func show_text(message: String, title: String, default_text: String = "", multiline: bool = false) -> String:
	# Create AcceptDialog instance
	var dialog = AcceptDialog.new()
	dialog.title = title
	dialog.dialog_text = message
	
	# Add cancel button
	dialog.add_cancel_button("Cancel")
	
	# Create input field based on multiline setting
	var input_field
	if multiline:
		input_field = TextEdit.new()
		input_field.text = default_text
		input_field.custom_minimum_size = Vector2(300, 100)
	else:
		input_field = LineEdit.new()
		input_field.text = default_text
		input_field.custom_minimum_size = Vector2(300, 0)
	
	# Add input field to dialog
	dialog.add_child(input_field)
	
	# Register LineEdit for Enter key if single line
	if not multiline:
		dialog.register_text_enter(input_field)
	
	# Add dialog to scene tree (required for editor plugins)
	EditorInterface.get_base_control().add_child(dialog)
	

	TreeDebug.msg("Showing text input: " + title)
	
	# Connect signals with one-shot to prevent multiple emissions
	dialog.confirmed.connect(func(): 
		text_result.emit(input_field.text)
	, CONNECT_ONE_SHOT)
	
	dialog.canceled.connect(func(): 
		text_result.emit("")
	, CONNECT_ONE_SHOT)
	
	# Center and show dialog
	dialog.popup_centered()
	
	# Focus the input field
	input_field.grab_focus()
	
	# Wait for our custom signal
	var result = await text_result
	
	# Hide dialog first to prevent exclusive window issues
	dialog.hide()
	
	# Use call_deferred for safe cleanup after signal processing is complete
	dialog.call_deferred("queue_free")
	
	return result
	
var active_progress_dialog: AcceptDialog = null

#region Progress Dialog
func show_progress(message: String, title: String, show_cancel: bool = false) -> AcceptDialog:
	# Create AcceptDialog instance
	var dialog = AcceptDialog.new()
	dialog.title = title
	dialog.dialog_text = ""
	dialog.unresizable = false
	dialog.exclusive = false  # Allow interaction with editor while showing
	
	# Hide OK button by default for progress dialogs
	dialog.get_ok_button().hide()
	
	# Add cancel button if requested
	if show_cancel:
		dialog.add_cancel_button("Cancel")
		dialog.canceled.connect(func():
			dialog_result.emit(false)
		)
	
	# Create VBoxContainer for content
	var container = VBoxContainer.new()
	container.custom_minimum_size = Vector2(300, 0)
	
	# Add message label
	var label = Label.new()
	label.name = "ProgressLabel"
	label.text = message
	label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	container.add_child(label)
	
	# Add spacing
	var spacer = Control.new()
	spacer.custom_minimum_size = Vector2(0, 10)
	container.add_child(spacer)
	
	# Add progress bar (indeterminate style)
	var progress = ProgressBar.new()
	progress.name = "ProgressBar"
	progress.show_percentage = false
	progress.custom_minimum_size = Vector2(280, 20)
	container.add_child(progress)
	
	dialog.add_child(container)
	
	# Add dialog to scene tree
	EditorInterface.get_base_control().add_child(dialog)
	
	TreeDebug.msg("Showing progress: " + title)
	
	# Center and show dialog
	dialog.popup_centered()
	
	# Store reference
	active_progress_dialog = dialog
	
	return dialog

func update_progress(dialog: AcceptDialog, message: String = "", progress: float = -1.0) -> void:
	if dialog == null or not is_instance_valid(dialog):
		return
	
	# Update message if provided
	if message != "":
		var label = dialog.find_child("ProgressLabel", true, false) as Label
		if label:
			label.text = message
	
	# Update progress bar if value provided (-1 = indeterminate)
	var progress_bar = dialog.find_child("ProgressBar", true, false) as ProgressBar
	if progress_bar:
		if progress >= 0.0:
			progress_bar.value = progress
			progress_bar.show_percentage = true
		else:
			# Indeterminate animation
			progress_bar.value = fmod(Time.get_ticks_msec() / 10.0, 100.0)

func close_progress(dialog: AcceptDialog) -> void:
	if dialog == null or not is_instance_valid(dialog):
		return
	
	dialog.hide()
	dialog.queue_free()
	
	if active_progress_dialog == dialog:
		active_progress_dialog = null
#endregion 
