# spinalcord
# https://github.com/spinalcord/animation-tree-tree-godot
# 
# This file is part of animation-tree-tree-godot.
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public.
#
# NOTE: The output generated by this addon is not affected by this license.

class_name FilePatcher
extends RefCounted

# ==============================================================================
# Configuration
# ==============================================================================

## Directory where checkpoints will be stored.
const CHECKPOINT_DIR: String = "user://backups/"

## Similarity threshold for fuzzy matching (0.0 to 1.0).
const SIMILARITY_THRESHOLD: float = 0.85

# ==============================================================================
# Public API
# ==============================================================================

## Main function to patch a file.
## returns: A Dictionary containing { "success": bool, "log": String, "errors": Array[String] }
func patch_file(file_path: String, patch_content: String, make_checkpoint: bool = true) -> Dictionary:
	var result = {
		"success": false,
		"log": "",
		"errors": []
	}
	
	var file = FileAccess.open(file_path, FileAccess.READ)
	if file == null:
		result.errors.append("File not found or not readable: " + file_path)
		return result
	
	var content = file.get_as_text()
	file.close() # Close reading handle
	
	# Create checkpoint if requested
	if make_checkpoint:
		var checkpoint_id = create_checkpoint(file_path, content)
		result.log += "Checkpoint created: " + checkpoint_id + "\n"

	# Apply patches
	var patch_result = _apply_patches(content, patch_content)
	
	result.log += patch_result.log
	result.errors.append_array(patch_result.errors)
	
	if patch_result.success:
		# Write back to file
		var write_file = FileAccess.open(file_path, FileAccess.WRITE)
		if write_file == null:
			result.errors.append("Could not write to file: " + file_path)
			result.success = false
		else:
			write_file.store_string(patch_result.new_content)
			write_file.close()
			result.success = true
			result.log += "File patched successfully: " + file_path + "\n"
	else:
		result.success = false
		result.log += "Patching failed. No changes written to disk.\n"
		
	return result

## Creates a copy of the current file content with a timestamp.
## returns: The filename of the checkpoint.
func create_checkpoint(original_path: String, content: String) -> String:
	if not DirAccess.dir_exists_absolute(CHECKPOINT_DIR):
		DirAccess.make_dir_recursive_absolute(CHECKPOINT_DIR)
	
	var filename = original_path.get_file()
	var timestamp = str(Time.get_unix_time_from_system()).replace(".", "_")
	var checkpoint_name = filename + "_" + timestamp + ".ckpt"
	var full_path = CHECKPOINT_DIR + checkpoint_name
	
	var file = FileAccess.open(full_path, FileAccess.WRITE)
	if file:
		file.store_string(content)
		file.close()
		return checkpoint_name
	return ""

## Restores a file from a specific checkpoint file name (located in CHECKPOINT_DIR).
func restore_checkpoint(checkpoint_name: String, target_path: String) -> bool:
	var source_path = CHECKPOINT_DIR + checkpoint_name
	if not FileAccess.file_exists(source_path):
		return false
	
	var source_file = FileAccess.open(source_path, FileAccess.READ)
	var content = source_file.get_as_text()
	source_file.close()
	
	var target_file = FileAccess.open(target_path, FileAccess.WRITE)
	if target_file:
		target_file.store_string(content)
		target_file.close()
		return true
		
	return false

## Lists all available checkpoints for a specific file name (or all if empty).
func list_checkpoints(filter_filename: String = "") -> Array[String]:
	var checkpoints: Array[String] = []
	var dir = DirAccess.open(CHECKPOINT_DIR)
	if dir:
		dir.list_dir_begin()
		var file_name = dir.get_next()
		while file_name != "":
			if not dir.current_is_dir():
				if filter_filename == "" or file_name.begins_with(filter_filename):
					checkpoints.append(file_name)
			file_name = dir.get_next()
	return checkpoints

# ==============================================================================
# Internal Logic
# ==============================================================================

func _apply_patches(content: String, patch_text: String) -> Dictionary:
	var blocks = _extract_patch_blocks(patch_text)
	var log_msg = "Found " + str(blocks.size()) + " patch block(s)\n"
	var errors = []
	var current_content = content
	
	if blocks.size() == 0:
		errors.append("No patch blocks found in patch text.")
		return {"success": false, "new_content": content, "errors": errors, "log": log_msg}

	var block_index = 1
	for block in blocks:
		var start_marker = block.start_marker
		var end_marker = block.end_marker
		var parts = block.parts
		
		log_msg += "Processing block " + str(block_index) + ": " + start_marker + "/" + end_marker + "\n"
		
		var result = {"success": false, "content": current_content, "error": "Unknown format"}
		
		# Dispatch based on markers
		if start_marker == "SEARCH" and end_marker == "REPLACE":
			result = _apply_search_replace(current_content, parts)
		elif start_marker == "SEARCH" and end_marker == "INSERT-IF-NOT-EXISTS":
			result = _apply_insert_if_not_exists(current_content, parts)
		elif start_marker == "REGEX" and end_marker == "REPLACE":
			result = _apply_regex_replace(current_content, parts)
		else:
			result.error = "Unknown format marker combination"
			
		if result.success:
			current_content = result.content
			log_msg += "  SUCCESS: Block " + str(block_index) + " applied\n"
		else:
			var err = "Block " + str(block_index) + " (" + start_marker + "/" + end_marker + "): " + result.error
			errors.append(err)
			log_msg += "  ERROR: " + err + "\n"
			
		block_index += 1
	
	return {
		"success": errors.size() == 0, 
		"new_content": current_content, 
		"errors": errors, 
		"log": log_msg
	}

func _extract_patch_blocks(text: String) -> Array:
	var blocks = []
	var lines = text.split("\n")
	var current_lines = []
	var inside = false
	var start_marker = ""
	
	for line in lines:
		var stripped = line.strip_edges()
		
		# Start marker
		if stripped.begins_with("<<<<<<<"):
			inside = true
			current_lines = []
			start_marker = stripped.substr(7).strip_edges()
			continue
			
		# End marker
		if stripped.begins_with(">>>>>>>") and inside:
			var end_marker = stripped.substr(7).strip_edges()
			
			# Split by separator =======
			var separator_idx = -1
			for i in range(current_lines.size()):
				if current_lines[i].strip_edges() == "=======":
					separator_idx = i
					break
			
			var parts = []
			if separator_idx != -1:
				var part1 = "\n".join(PackedStringArray(current_lines.slice(0, separator_idx)))
				var part2 = "\n".join(PackedStringArray(current_lines.slice(separator_idx + 1)))
				parts = [part1, part2]
			else:
				parts = ["\n".join(PackedStringArray(current_lines))]
				
			blocks.append({
				"start_marker": start_marker,
				"end_marker": end_marker,
				"parts": parts
			})
			
			inside = false
			start_marker = ""
			current_lines = []
			continue
			
		if inside:
			current_lines.append(line)
			
	return blocks

# ==============================================================================
# Format Handlers
# ==============================================================================

func _apply_search_replace(content: String, parts: Array) -> Dictionary:
	if parts.size() != 2:
		return {"success": false, "content": content, "error": "SEARCH/REPLACE requires exactly 2 parts"}
		
	var search_text = parts[0]
	var replace_text = parts[1]
	
	# Try exact match first
	var exact_pos = content.find(search_text)
	if exact_pos != -1:
		var new_content = content.left(exact_pos) + replace_text + content.substr(exact_pos + search_text.length())
		return {"success": true, "content": new_content, "error": ""}
		
	# Fall back to fuzzy search
	var fuzzy_res = _fuzzy_search(content, search_text)
	if not fuzzy_res.found:
		return {"success": false, "content": content, "error": "Search text not found (even with fuzzy search)"}
		
	var new_content = content.left(fuzzy_res.start_pos) + replace_text + content.substr(fuzzy_res.end_pos)
	return {"success": true, "content": new_content, "error": ""}

func _apply_insert_if_not_exists(content: String, parts: Array) -> Dictionary:
	if parts.size() != 1:
		return {"success": false, "content": content, "error": "INSERT-IF-NOT-EXISTS requires exactly 1 part"}
	
	var insert_text = parts[0]
	if content.find(insert_text) != -1:
		return {"success": true, "content": content, "error": ""} # Already exists
		
	var new_content = content + "\n" + insert_text
	return {"success": true, "content": new_content, "error": ""}

func _apply_regex_replace(content: String, parts: Array) -> Dictionary:
	if parts.size() != 2:
		return {"success": false, "content": content, "error": "REGEX/REPLACE requires exactly 2 parts"}
		
	var pattern = parts[0]
	var replacement = parts[1]
	
	var regex = RegEx.new()
	var err = regex.compile(pattern)
	if err != OK:
		return {"success": false, "content": content, "error": "Invalid regex pattern"}
		
	var search_res = regex.search(content)
	if search_res == null:
		return {"success": false, "content": content, "error": "Regex pattern not found"}
		
	var new_content = regex.sub(content, replacement, true) # true replaces all occurrences? Python logic said sub usually replaces all if count not specified
	# Note: Python's default sub replaces all. If we want only one, we'd handle differently, 
	# but usually patching implies global or specific. The python script didn't specify count in `compiled.sub`.
	
	return {"success": true, "content": new_content, "error": ""}

# ==============================================================================
# Fuzzy Matching Utilities
# ==============================================================================

func _fuzzy_search(content: String, search_text: String) -> Dictionary:
	var normalized_search = _normalize_text(search_text)
	var normalized_search_lines = normalized_search.split("\n", false) # false = skip empty
	
	if normalized_search_lines.size() == 0:
		return {"found": false, "start_pos": -1, "end_pos": -1}
		
	var content_lines = content.split("\n") # Keep all lines to calc positions
	# Note: split("\n") drops the separator, we need to reconstruct positions carefully.
	
	# Iterate over content lines
	for i in range(content_lines.size()):
		var match_found = true
		var search_idx = 0
		var current_content_idx = i
		
		# Try to match the sequence
		while search_idx < normalized_search_lines.size():
			if current_content_idx >= content_lines.size():
				match_found = false
				break
			
			var line_stripped = content_lines[current_content_idx].strip_edges()
			
			# Skip empty lines in content matching Python logic
			if line_stripped == "":
				current_content_idx += 1
				continue
				
			var target_line = normalized_search_lines[search_idx]
			
			# Check similarity
			if line_stripped == target_line:
				# Exact line match
				search_idx += 1
				current_content_idx += 1
			elif _similarity_ratio(line_stripped, target_line) >= SIMILARITY_THRESHOLD:
				# Fuzzy match
				search_idx += 1
				current_content_idx += 1
			else:
				match_found = false
				break
		
		if match_found:
			# Calculate actual byte/char positions for string replacement
			# This is tricky because split removed \n. We must assume standard line endings or reconstruct.
			# We will calculate based on original content accumulation.
			
			var start_pos = _get_char_index_at_line(content, i)
			# The end line is current_content_idx - 1 (since it incremented after match)
			# We need the position AFTER that line.
			var end_pos = _get_char_index_at_line(content, current_content_idx)
			
			return {"found": true, "start_pos": start_pos, "end_pos": end_pos}
			
	return {"found": false, "start_pos": -1, "end_pos": -1}

func _normalize_text(text: String) -> String:
	var lines = text.split("\n")
	var norm_lines = []
	for line in lines:
		norm_lines.append(line.strip_edges())
	return "\n".join(PackedStringArray(norm_lines))

## Calculates Levenshtein distance based similarity (0.0 to 1.0)
func _similarity_ratio(s1: String, s2: String) -> float:
	if s1 == s2: return 1.0
	if s1.length() == 0 or s2.length() == 0: return 0.0
	
	var dist = _levenshtein_distance(s1, s2)
	var max_len = max(s1.length(), s2.length())
	return 1.0 - (float(dist) / float(max_len))

## Standard Levenshtein implementation
func _levenshtein_distance(s1: String, s2: String) -> int:
	var m = s1.length()
	var n = s2.length()
	var d = []
	
	for i in range(m + 1):
		d.append([])
		for j in range(n + 1):
			d[i].append(0)
			
	for i in range(m + 1): d[i][0] = i
	for j in range(n + 1): d[0][j] = j
	
	for j in range(1, n + 1):
		for i in range(1, m + 1):
			var cost = 0
			if s1[i - 1] != s2[j - 1]:
				cost = 1
			d[i][j] = min(d[i - 1][j] + 1, min(d[i][j - 1] + 1, d[i - 1][j - 1] + cost))
			
	return d[m][n]

## Helper to find character index in original string corresponding to start of line N
func _get_char_index_at_line(full_text: String, line_index: int) -> int:
	var current_line = 0
	var pos = 0
	var length = full_text.length()
	
	if line_index == 0: return 0
	
	while pos < length:
		if full_text[pos] == "\n":
			current_line += 1
			if current_line == line_index:
				return pos + 1
		pos += 1
	
	return pos
