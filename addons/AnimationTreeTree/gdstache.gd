# spinalcord
# https://github.com/spinalcord/animation-tree-tree-godot
# 
# This file is part of animation-tree-tree-godot.
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public.
#
# NOTE: The output generated by this addon is not affected by this license.

## Lightweight Mustache template engine implementation for Godot
class_name GDStache

func _init():
	pass

enum TokenType {
	TEXT,
	VARIABLE,
	UNESCAPED_VARIABLE,
	SECTION_OPEN,
	SECTION_CLOSE,
	INVERTED_SECTION_OPEN,
	COMMENT,
	PARTIAL,
	SET_DELIMITER
}

class Token:
	var type: TokenType
	var value: String
	var indent: String = ""
	var line_standalone: bool = false
	
	func _init(t: TokenType, v: String):
		type = t
		value = v

class Context:
	var stack: Array = []
	
	func _init(data):
		push(data)
	
	func push(data) -> void:
		stack.push_back(data)
	
	func pop() -> void:
		if stack.size() > 0:
			stack.pop_back()
	
	func lookup(key: String):
		if key == ".":
			return stack.back()
		
		# Try from innermost to outermost context
		for i in range(stack.size() - 1, -1, -1):
			var context = stack[i]
			var result = _get_value(context, key)
			if result != null:
				return result
		return null
	
	func _get_value(obj, key: String):
		if obj == null:
			return null
		
		# Handle nested keys like "person.name"
		var parts = key.split(".")
		var current = obj
		
		for part in parts:
			if current is Dictionary:
				if part in current:
					current = current[part]
				else:
					return null
			elif current is Object:
				if part in current:
					current = current.get(part)
				else:
					return null
			else:
				return null
		
		return current

var partials: Dictionary = {}
var open_tag: String = "{{"
var close_tag: String = "}}"
var enable_html_escaping: bool = false  # Set to true if you need HTML escaping

## Render a template with the given data
func render(template: String, data, partial_dict: Dictionary = {}) -> String:
	partials = partial_dict
	var tokens = tokenize(template)
	tokens = parse_standalone_lines(tokens, template)
	var tree = build_tree(tokens)
	var ctx = Context.new(data)
	return render_tree(tree, ctx)

## Tokenize the template string
func tokenize(template: String) -> Array:
	var tokens: Array = []
	var pos = 0
	var template_length = template.length()
	
	while pos < template_length:
		var open_pos = template.find(open_tag, pos)
		
		if open_pos == -1:
			# No more tags, add remaining text
			if pos < template_length:
				tokens.append(Token.new(TokenType.TEXT, template.substr(pos)))
			break
		
		# Add text before tag
		if open_pos > pos:
			tokens.append(Token.new(TokenType.TEXT, template.substr(pos, open_pos - pos)))
		
		# Check for triple mustache
		var is_triple = false
		var tag_start = open_pos + open_tag.length()
		if tag_start < template_length and template[tag_start] == "{":
			is_triple = true
			tag_start += 1
		
		# Find closing tag
		var close_sequence = "}}}" if is_triple else close_tag
		var close_pos = template.find(close_sequence, tag_start)
		if close_pos == -1:
			# Unclosed tag, treat as text
			tokens.append(Token.new(TokenType.TEXT, template.substr(open_pos)))
			break
		
		# Extract tag content
		var tag_content = template.substr(tag_start, close_pos - tag_start)
		
		# Parse tag
		var token = parse_tag(tag_content, is_triple)
		if token != null:
			tokens.append(token)
		
		pos = close_pos + close_sequence.length()
	
	return tokens

## Parse a single tag
func parse_tag(content: String, is_triple: bool) -> Token:
	content = content.strip_edges()
	
	if content.is_empty():
		return Token.new(TokenType.TEXT, "")
	
	# Triple mustache always means unescaped
	if is_triple:
		return Token.new(TokenType.UNESCAPED_VARIABLE, content)
	
	var first_char = content[0]
	
	match first_char:
		"!":
			# Comment
			return Token.new(TokenType.COMMENT, "")
		"#":
			# Section open
			var key = content.substr(1).strip_edges()
			return Token.new(TokenType.SECTION_OPEN, key)
		"^":
			# Inverted section
			var key = content.substr(1).strip_edges()
			return Token.new(TokenType.INVERTED_SECTION_OPEN, key)
		"/":
			# Section close
			var key = content.substr(1).strip_edges()
			return Token.new(TokenType.SECTION_CLOSE, key)
		">":
			# Partial
			var key = content.substr(1).strip_edges()
			return Token.new(TokenType.PARTIAL, key)
		"=":
			# Set delimiter
			if content.ends_with("="):
				var delim_content = content.substr(1, content.length() - 2).strip_edges()
				return Token.new(TokenType.SET_DELIMITER, delim_content)
			return Token.new(TokenType.VARIABLE, content)
		"&":
			# Unescaped variable
			var key = content.substr(1).strip_edges()
			return Token.new(TokenType.UNESCAPED_VARIABLE, key)
		_:
			# Regular variable
			return Token.new(TokenType.VARIABLE, content)

## Parse standalone lines (lines with only whitespace and a tag)
func parse_standalone_lines(tokens: Array, template: String) -> Array:
	var i = 0
	while i < tokens.size():
		var token = tokens[i]
		
		# Check if this is a standalone tag type
		if token.type in [TokenType.SECTION_OPEN, TokenType.SECTION_CLOSE, 
						  TokenType.INVERTED_SECTION_OPEN, TokenType.COMMENT, 
						  TokenType.PARTIAL]:
			
			var is_standalone = false
			var indent = ""
			
			# For comments inside sections, check if there are other non-whitespace tokens on the line
			var has_other_content = false
			if token.type == TokenType.COMMENT:
				# Look backwards for non-whitespace content after last newline
				if i > 0:
					var prev = tokens[i - 1]
					if prev.type != TokenType.TEXT:
						has_other_content = true
					elif prev.type == TokenType.TEXT:
						var text = prev.value
						var last_newline = text.rfind("\n")
						if last_newline == -1:
							if not text.strip_edges().is_empty():
								has_other_content = true
						else:
							var after_newline = text.substr(last_newline + 1)
							if not after_newline.strip_edges().is_empty():
								has_other_content = true
				
				# Look forwards for non-whitespace content before next newline
				if i < tokens.size() - 1:
					var next = tokens[i + 1]
					if next.type != TokenType.TEXT:
						has_other_content = true
					elif next.type == TokenType.TEXT:
						var text = next.value
						var first_newline = text.find("\n")
						if first_newline == -1:
							if not text.strip_edges().is_empty():
								has_other_content = true
						else:
							var before_newline = text.substr(0, first_newline)
							if not before_newline.strip_edges().is_empty():
								has_other_content = true
			
			if has_other_content:
				i += 1
				continue
			
			# Check previous token
			var prev_is_whitespace = false
			if i == 0:
				prev_is_whitespace = true
			elif i > 0:
				var prev = tokens[i - 1]
				if prev.type == TokenType.TEXT:
					var text = prev.value
					var last_newline = text.rfind("\n")
					if last_newline == -1:
						# No newline before, check if only whitespace from start
						if text.strip_edges().is_empty():
							prev_is_whitespace = true
							indent = text
					else:
						# Check text after last newline
						var after_newline = text.substr(last_newline + 1)
						if after_newline.strip_edges().is_empty():
							prev_is_whitespace = true
							indent = after_newline
			
			# Check next token
			var next_is_newline = false
			if i == tokens.size() - 1:
				next_is_newline = true
			elif i < tokens.size() - 1:
				var next = tokens[i + 1]
				if next.type == TokenType.TEXT:
					var text = next.value
					if text.begins_with("\r\n") or text.begins_with("\n") or text.begins_with("\r"):
						next_is_newline = true
					elif text.is_empty():
						next_is_newline = true
			
			# Mark as standalone if both conditions met
			if prev_is_whitespace and next_is_newline:
				is_standalone = true
				token.line_standalone = true
				token.indent = indent
				
				# Remove the indent from previous token
				if i > 0:
					var prev = tokens[i - 1]
					if prev.type == TokenType.TEXT:
						var text = prev.value
						var last_newline = text.rfind("\n")
						if last_newline == -1:
							prev.value = ""
						else:
							prev.value = text.substr(0, last_newline + 1)
				
				# Remove newline from next token
				if i < tokens.size() - 1:
					var next = tokens[i + 1]
					if next.type == TokenType.TEXT:
						if next.value.begins_with("\r\n"):
							next.value = next.value.substr(2)
						elif next.value.begins_with("\n") or next.value.begins_with("\r"):
							next.value = next.value.substr(1)
		
		i += 1
	
	return tokens

## Build a tree structure from tokens
func build_tree(tokens: Array) -> Array:
	var tree: Array = []
	var stack: Array = []
	var i = 0
	
	while i < tokens.size():
		var token = tokens[i]
		
		if token.type == TokenType.SECTION_OPEN or token.type == TokenType.INVERTED_SECTION_OPEN:
			var section = {
				"type": token.type,
				"key": token.value,
				"children": [],
				"indent": token.indent,
				"standalone": token.line_standalone
			}
			
			if stack.size() > 0:
				stack.back()["children"].append(section)
			else:
				tree.append(section)
			
			stack.push_back(section)
		
		elif token.type == TokenType.SECTION_CLOSE:
			if stack.size() > 0:
				var section = stack.back()
				if section["key"] == token.value:
					stack.pop_back()
		
		else:
			var node = {
				"type": token.type,
				"value": token.value,
				"indent": token.indent,
				"standalone": token.line_standalone
			}
			
			if stack.size() > 0:
				stack.back()["children"].append(node)
			else:
				tree.append(node)
		
		i += 1
	
	return tree

## Render the parse tree
func render_tree(tree: Array, ctx: Context) -> String:
	var result = ""
	
	for node in tree:
		match node["type"]:
			TokenType.TEXT:
				result += node["value"]
			
			TokenType.VARIABLE:
				var value = ctx.lookup(node["value"])
				if enable_html_escaping:
					result += escape_html(stringify(value))
				else:
					result += stringify(value)
			
			TokenType.UNESCAPED_VARIABLE:
				var value = ctx.lookup(node["value"])
				result += stringify(value)
			
			TokenType.SECTION_OPEN:
				var value = ctx.lookup(node["key"])
				result += render_section(node, ctx, value, false)
			
			TokenType.INVERTED_SECTION_OPEN:
				var value = ctx.lookup(node["key"])
				result += render_section(node, ctx, value, true)
			
			TokenType.PARTIAL:
				result += render_partial(node, ctx)
			
			TokenType.COMMENT:
				pass  # Comments produce no output
	
	return result

## Render a section or inverted section
func render_section(node: Dictionary, ctx: Context, value, inverted: bool) -> String:
	var should_render = is_truthy(value)
	if inverted:
		should_render = not should_render
	
	if not should_render:
		return ""
	
	# If value is an array, render for each item
	if value is Array and not inverted:
		var result = ""
		for item in value:
			ctx.push(item)
			result += render_tree(node["children"], ctx)
			ctx.pop()
		return result
	
	# If value is a dictionary or other truthy value, use it as context
	if not inverted and value != null and typeof(value) != TYPE_BOOL:
		ctx.push(value)
		var result = render_tree(node["children"], ctx)
		ctx.pop()
		return result
	
	# For true boolean or inverted sections
	return render_tree(node["children"], ctx)

## Render a partial
func render_partial(node: Dictionary, ctx: Context) -> String:
	var partial_name = node["value"]
	if partial_name not in partials:
		return ""
	
	var partial_template = partials[partial_name]
	var partial_tokens = tokenize(partial_template)
	partial_tokens = parse_standalone_lines(partial_tokens, partial_template)
	var partial_tree = build_tree(partial_tokens)
	
	# Render the partial
	var rendered = render_tree(partial_tree, ctx)
	
	# Apply indentation ONLY if this is a standalone partial
	if node["standalone"] and node["indent"] != "":
		var result = ""
		var pos = 0
		var line_start = true
		
		while pos < rendered.length():
			var c = rendered[pos]
			
			# Add indent at the start of each line
			if line_start and c != "\n" and c != "\r":
				result += node["indent"]
				line_start = false
			
			result += c
			
			# Track when we're at the start of a new line
			if c == "\n":
				line_start = true
			
			pos += 1
		
		return result
	
	return rendered

## Check if a value is truthy in Mustache terms
func is_truthy(value) -> bool:
	if value == null:
		return false
	if typeof(value) == TYPE_BOOL:
		return value
	if value is Array:
		return value.size() > 0
	if value is Dictionary:
		return true
	if value is String:
		return true
	if typeof(value) == TYPE_INT or typeof(value) == TYPE_FLOAT:
		return true
	return true

## Convert value to string
func stringify(value) -> String:
	if value == null:
		return ""
	if typeof(value) == TYPE_BOOL:
		return ""  # Booleans don't render
	if value is String:
		return value
	if typeof(value) == TYPE_FLOAT:
		# Format floats without unnecessary decimals
		var s = str(value)
		if s.contains("."):
			s = s.trim_suffix("0").trim_suffix(".")
		return s
	return str(value)

## Escape HTML entities
func escape_html(text: String) -> String:
	return text.replace("&", "&amp;") \
			   .replace("<", "&lt;") \
			   .replace(">", "&gt;") \
			   .replace("\"", "&quot;") \
			   .replace("'", "&#39;")

