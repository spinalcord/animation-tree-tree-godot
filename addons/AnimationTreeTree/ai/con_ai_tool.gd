# spinalcord
# https://github.com/spinalcord/animation-tree-tree-godot
# 
# This file is part of animation-tree-tree-godot.
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public.
#
# NOTE: The output generated by this addon is not affected by this license.

# Base class for AI tools with automatic documentation extraction
class_name ConAITool

var _animation_tree: AnimationTree
var _feedback: FeedbackDialog

func _init(container: DependencyContainer):
	_animation_tree = container.grab("CurrentAnimationTree")
	_feedback = container.grab("FeedbackDialog")
	extract_tool_descriptions()

var tool_descriptions: Dictionary = {}

func extract_tool_descriptions() -> void:
	var script_path = get_script().resource_path
	var file = FileAccess.open(script_path, FileAccess.READ)
	if not file:
		push_error("Could not read script file: " + script_path)
		return
	
	var content = file.get_as_text()
	file.close()
	
	parse_documentation_comments(content)

func parse_documentation_comments(content: String) -> void:
	var lines = content.split("\n")
	var current_doc = ""
	var current_params = {}
	var in_doc_block = false
	
	for i in range(lines.size()):
		var line = lines[i].strip_edges()
		
		# Documentation comment found
		if line.begins_with("##"):
			var doc_content = line.substr(2).strip_edges()
			
			# Check if it's a parameter documentation
			var param_match = extract_param_doc(doc_content)
			if param_match.has("param_name"):
				current_params[param_match.param_name] = param_match.description
			else:
				# Regular documentation
				current_doc += doc_content + " "
			
			in_doc_block = true
		
		# Function definition found
		elif line.begins_with("func tool_") and in_doc_block:
			var func_name = extract_function_name(line)
			if func_name:
				var tool_name = func_name.trim_prefix("tool_")
				
				# Store main description and parameter descriptions
				tool_descriptions[tool_name] = {
					"description": current_doc.strip_edges(),
					"parameters": current_params
				}
			
			current_doc = ""
			current_params = {}
			in_doc_block = false
		
		# Non-documentation line - reset if not empty
		elif not line.is_empty() and not line.begins_with("##"):
			if in_doc_block:
				current_doc = ""
				current_params = {}
				in_doc_block = false

# Extract parameter documentation from a line like "[param name]: description"
func extract_param_doc(doc_line: String) -> Dictionary:
	var regex = RegEx.new()
	regex.compile(r"\[param\s+(\w+)\]:\s*(.+)")
	var result = regex.search(doc_line)
	
	if result:
		return {
			"param_name": result.get_string(1),
			"description": result.get_string(2).strip_edges()
		}
	else:
		return {}

func extract_function_name(line: String) -> String:
	var start = line.find("func ") + 5
	var end = line.find("(")
	if end == -1:
		end = line.find(":")
	if end == -1:
		end = line.length()
	return line.substr(start, end - start).strip_edges()

func get_structure() -> Array:
	var methods = get_method_list()
	var tool_schemas = []
	
	for method in methods:
		if method.name.begins_with("tool_"):
			var tool_name = method.name.trim_prefix("tool_")
			var tool_info = tool_descriptions.get(tool_name, {})
			
			# Extract description and parameters
			var description = ""
			var param_docs = {}
			
			if tool_info is Dictionary:
				description = tool_info.get("description", "No description available")
				param_docs = tool_info.get("parameters", {})
			else:
				# Fallback for old string format
				description = str(tool_info) if tool_info else "No description available"
			
			var function_schema = {
				"type": "function",
				"function": {
					"name": tool_name,
					"description": description,
					"parameters": {
						"type": "object",
						"properties": {},
						"required": []
					}
				}
			}
			
			if not method.args.is_empty():
				for arg in method.args:
					var arg_name = arg.name
					function_schema.function.parameters.required.append(arg_name)
					
					# Use parameter documentation if available
					var param_description = param_docs.get(arg_name, "")
					
					function_schema.function.parameters.properties[arg_name] = {
						"type": variant_type_to_json_type(arg.type),
						"description": param_description
					}
			
			tool_schemas.append(function_schema)
	
	return tool_schemas

func variant_type_to_json_type(variant_type: int) -> String:
	match variant_type:
		TYPE_BOOL:
			return "boolean"
		TYPE_INT, TYPE_FLOAT:
			return "number"
		TYPE_STRING:
			return "string"
		TYPE_DICTIONARY, TYPE_OBJECT:
			return "object"
		TYPE_ARRAY:
			return "array"
		_:
			return "string"

func call_tool(tool_name: StringName, args: Dictionary):
	var method_name = "tool_" + tool_name
	if not has_method(method_name):
		push_error("Tool method '" + method_name + "' does not exist on this object.")
		return "Error: Method not found"
		
	var method_info_list = get_method_list().filter(func(m): return m.name == method_name)
	if method_info_list.is_empty():
		push_error("Could not retrieve metadata for method '" + method_name + "'.")
		return "Error: Method metadata not found"
		
	var expected_args_info = method_info_list[0].args
	var sorted_args_array = []
	
	for arg_info in expected_args_info:
		var arg_name = arg_info.name
		if not args.has(arg_name):
			push_error("Missing argument '" + arg_name + "' when calling tool")
			return "Error: Missing argument " + arg_name
		sorted_args_array.append(args[arg_name])
	
	var result = callv(method_name, sorted_args_array)
	return result if result != null else "Tool executed successfully"

# Debug function to TreeDebug.msg all extracted descriptions
func print_extracted_descriptions() -> void:
	TreeDebug.msg("Extracted tool descriptions:")
	for tool_name in tool_descriptions:
		var tool_info = tool_descriptions[tool_name]
		if tool_info is Dictionary:
			TreeDebug.msg("  " + tool_name + ":")
			TreeDebug.msg("    Description: " + tool_info.get("description", ""))
			var params = tool_info.get("parameters", {})
			if not params.is_empty():
				TreeDebug.msg("    Parameters:")
				for param_name in params:
					TreeDebug.msg("      " + param_name + ": " + params[param_name])
		else:
			TreeDebug.msg("  " + tool_name + ": " + str(tool_info))
