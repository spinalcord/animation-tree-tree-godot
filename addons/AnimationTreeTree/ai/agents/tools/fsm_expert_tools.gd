# spinalcord
# https://github.com/spinalcord/animation-tree-tree-godot
# 
# This file is part of animation-tree-tree-godot.
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public.
#
# NOTE: The output generated by this addon is not affected by this license.

# SampleTools.gd
class_name FSMExpertTools
extends ConAITool

## CRITICAL: IF users question is not sufficient OR you are not sure what to do, use this tool.
## ALWAYS call the method where you can get the blueprint with AVAIBLE target_paths FIRST before using this function!
## You need to understand the current AnimationTree structure before asking targeted questions.
## Use ONLY YES/NO decisions.
## Ask: "Should I ...?" ✓
## WRONG: "Can you describe your problem?" ✗
## WRONG: "What do you want to do?" ✗
## [param questions]: Array of question strings ["Should I x?", "Do you want y?", ...]
## Returns String with user's answers or empty String if cancelled.
func tool_ask_user_decisions(questions: Array) -> String:
	# Convert questions array to dictionary format for show_decisions
	var checkboxes: Dictionary = {}
	for i in range(questions.size()):
		var key = "question_%d" % i
		checkboxes[key] = [questions[i], false]
	
	var result = await _feedback.show_decisions("Your AI-Assistant wants to clarify something:", "Assistant", checkboxes, false)
	
	# Convert dictionary result to readable string
	if result.is_empty():
		return ""
	
	var output: String = ""
	for question in result.keys():
		var answer = "YES" if result[question] else "NO"
		output += question + ": " + answer + "\n"
	print(output.strip_edges())
	return output.strip_edges()

## You will likely use this function if USER wants to change something
## You can call this function to get the structure of your chosen target_paths
## IF you choose an empty string as target_path you get the complete AnimationTree
## structure.
## [param target_paths]: target paths e.g. ["", "StateA/StateB"] returns structure of Root and structure of StateB
func tool_get_blueprint(target_paths: Array) -> Array[String]:
	
	var export_manager: ExportManager = ExportManager.new(_container)
	
	# This condition returns the whole tree, we don't need the other paths additionally, this saves expensive context.
	if target_paths.has("") or target_paths.has("Root"):
		target_paths.clear()
		return [export_manager.export_tree_as_yaml(_animation_tree, [])]
	
	var return_array: Array[String] = []
	for target_path in target_paths:
		var yaml: String = export_manager.export_tree_as_yaml(_animation_tree, [target_path])
		return_array.append(yaml)
		TreeDebug.msg(yaml)
	return return_array

## Deletes transitions from one or more state machines.
## [param target_paths]: Paths to state machines (e.g. ["PlayerAnimationController/GroundState"])
## [param transitions]: Array of transitions [{"from": "state1", "to": "state2"}]
func tool_delete_transitions(target_paths: Array, transitions: Array) -> bool:
	print(target_paths)
	print(transitions)
	var tree_builder: AnimationTreeBuilder = AnimationTreeBuilder.new(_animation_tree)
	var all_success: bool = true
	
	for target_path in target_paths:
		var success: bool = tree_builder.delete_transitions(target_path, transitions)
		if success:
			TreeDebug.msg("Successfully deleted %d transition(s) from %s" % [transitions.size(), target_path])
		else:
			TreeDebug.msg("Failed to delete transitions from %s" % target_path)
			all_success = false
	return all_success

## Deletes nodes from the AnimationTree.
## WARNING: Deleting nodes in StateMachines will also remove all transitions connected to those nodes.
## [param node_paths]: Array of node paths to delete (e.g. ["PlayerAnimationController/IdleState", "PlayerAnimationController/WalkState"])
## Returns true if all deletions succeeded, false if any failed.
## Note: BlendSpace1D/2D points cannot be deleted and must be removed manually in the AnimationTree viewport.
func tool_delete_nodes(node_paths: Array) -> bool:
	var tree_builder: AnimationTreeBuilder = AnimationTreeBuilder.new(_animation_tree)
	var all_success: bool = true
	var deleted_count: int = 0
	var failed_count: int = 0
	
	for node_path in node_paths:
		var success: bool = tree_builder.delete_node(node_path)
		if success:
			deleted_count += 1
			TreeDebug.msg("Successfully deleted node: %s" % node_path)
		else:
			failed_count += 1
			TreeDebug.msg("Failed to delete node: %s" % node_path)
			all_success = false
	
	TreeDebug.msg("Deletion summary: %d succeeded, %d failed out of %d total" % [deleted_count, failed_count, node_paths.size()])
	return all_success

## Deletes connections from one or more BlendTrees.
## [param target_paths]: Paths to BlendTrees (e.g. ["SomeController/SomeBlendTree"])
## [param connections]: Array of connections [{"to": "node_name", "to_input": "in"}]
## Returns true if all deletions succeeded, false if any failed.
func tool_delete_connections(target_paths: Array, connections: Array) -> bool:
	print(target_paths)
	print(connections)
	var tree_builder: AnimationTreeBuilder = AnimationTreeBuilder.new(_animation_tree)
	var all_success: bool = true
	
	for target_path in target_paths:
		var success: bool = tree_builder.delete_connections(target_path, connections)
		if success:
			TreeDebug.msg("Successfully deleted %d connection(s) from %s" % [connections.size(), target_path])
		else:
			TreeDebug.msg("Failed to delete connections from %s" % target_path)
			all_success = false
	
	return all_success
