# spinalcord
# https://github.com/spinalcord/animation-tree-tree-godot
# 
# This file is part of animation-tree-tree-godot.
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public.
#
# NOTE: The output generated by this addon is not affected by this license.

class_name AnimationTreeScriptBuilder
extends RefCounted

var _builder: AnimationTreeBuilder
var _yaml_parser: YamlDeserializer
var _errors: Array[String] = []

# Track positioning data for circular arrangement
var _level_counters: Dictionary = {}  # path -> counter for each level
var _level_totals: Dictionary = {}    # path -> total children count

func _init():
	_yaml_parser = YamlDeserializer.new()

# ============================================================================
# PUBLIC API
# ============================================================================

func build_from_script(animation_tree: AnimationTree, script_text: String) -> bool:
	_builder = AnimationTreeBuilder.new(animation_tree)
	_errors.clear()
	_level_counters.clear()
	_level_totals.clear()
	var target_path: String
	# Parse YAML
	var parsed = _yaml_parser.from_text(script_text)
	if parsed == null:
		_add_error("Failed to parse YAML script")
		return false
	
	if not parsed.has("target_path"):
		_add_error("Script must specify 'target_path'")
	else:
		target_path = parsed["target_path"]
	
	var blueprint: Dictionary = parsed.get("Blueprint", {})
	
	if blueprint.is_empty():
		TreeDebug.msg("Script must specify 'Blueprint' node")
		return false
	#region apply blueprint conventions
	if blueprint.has("name") == false:
		if target_path != null:
			TreeDebug.msg("name key missing AND target_path exists => take last segment of target path for name key" + target_path)
			if target_path.strip_edges() == "":
				blueprint["name"] = ""
			else:
				blueprint["name"] = target_path.get_file()
		else:
			_add_error("name key missing in blueprint.")
	else:
		if target_path.strip_edges() == "":
			var current_blueprint_name: String = (blueprint["name"] as String).to_lower()
			if current_blueprint_name == "root":
				blueprint["name"] = ""
	
	if target_path.get_file() == blueprint.get("name", null):
		target_path = target_path.get_base_dir()
		TreeDebug.msg("last target_path segment was identical with blueprint name. target_path changed to " + target_path)
	#endregion
			
	#if blueprint.has("type") == false:
	#	_add_error("type key is missing in blueprint")
	
	if _errors.size() > 0:
		var error_message = ""
		for err in _errors:
			TreeDebug.msg("ERROR:" + err)
			error_message += "- " + err + "\n"
		TreeDebug.msg(error_message.strip_edges(), true)
		return false
	
	TreeDebug.msg("=== Building from YAML script ===")
	TreeDebug.msg("Target path: " + target_path)
	TreeDebug.msg("Building root node: " + str(blueprint.get("name", "unnamed")))
	# Pre-calculate children counts for circular positioning
	_precalculate_children_counts(target_path, blueprint)
	# Validate nodes don't already exist
	throw_out_existing_non_container_nodes(target_path, blueprint) # e.g. idle already exists => throw it out
	# Validate all animations exist BEFORE building
	if not _validate_animations(animation_tree, blueprint):
		_add_error("ERROR: Build aborted your AI model assumes Animations that don't exist.")
	
	if _errors.size() > 0:
		var error_message = ""
		for err in _errors:
			TreeDebug.msg("ERROR: " + err)
			error_message += err + "\n"
		TreeDebug.msg(error_message.strip_edges(), true)
		return false
	
	# Build the root node
	if not _build_node(target_path, blueprint):
		return false
	
	# Build connections if this is a BlendTree and has connections
	var connections = blueprint.get("connections", [])
	if not connections.is_empty():
		TreeDebug.msg("=== Building connections ===")
		var node_path = target_path
		if not blueprint.get("name", "").is_empty():
			node_path = target_path + "/" + blueprint.get("name")
		
		if not _build_connections(node_path, connections):
			return false
	
	TreeDebug.msg("=== Build completed successfully ===")
	return true

# ============================================================================
# CIRCULAR POSITIONING
# ============================================================================

func _precalculate_children_counts(parent_path: String, node_data: Dictionary) -> void:
	var node_name = node_data.get("name", "")
	var children = node_data.get("children", [])
	
	if not node_name.is_empty():
		var node_path = parent_path + "/" + node_name
		_level_totals[node_path] = children.size()
		_level_counters[node_path] = 0
		
		# Recursively calculate for children
		for child_data in children:
			_precalculate_children_counts(node_path, child_data)

func _calculate_circular_position(parent_path: String, index: int, total: int, center: Vector2 = Vector2(300, 300), radius: float = 150.0) -> Vector2:
	if total <= 1:
		return center
	
	# Calculate angle for this position (distribute evenly around circle)
	var angle = 2.0 * PI * float(index) / float(total)
	
	# Add slight spiral effect based on level depth
	var level_depth = parent_path.count("/")
	var spiral_offset = level_depth * 20.0  # Each level spirals outward slightly
	var final_radius = radius + spiral_offset
	
	# Calculate position
	var x = center.x + cos(angle) * final_radius
	var y = center.y + sin(angle) * final_radius
	
	return Vector2(x, y)

func _get_center_position_for_parent(parent_path: String) -> Vector2:
	# Get center based on parent type and existing content
	var parent_node = _builder.get_node(parent_path)
	
	if parent_node is AnimationNodeStateMachine:
		# For state machines, use existing logic but with circular adjustment
		var existing_children = _builder.get_child_names(parent_path)
		if existing_children.is_empty():
			return Vector2(300, 300)  # Default center
		
		# Calculate center of existing nodes
		var center = Vector2.ZERO
		var count = 0
		for child_name in existing_children:
			var pos = _builder.get_node_position(parent_path + "/" + child_name)
			center += pos
			count += 1
		
		return center / count if count > 0 else Vector2(300, 300)
	
	elif parent_node is AnimationNodeBlendTree:
		# For blend trees, position more compactly
		return Vector2(200, 200)
	
	return Vector2(300, 300)  # Default fallback

# ============================================================================
# VALIDATION (unchanged)
# ============================================================================

func throw_out_existing_non_container_nodes(parent_path: String, node_data: Dictionary) -> void:
	var node_name = node_data.get("name", "")
	
	if not node_name.is_empty():
		var full_path = parent_path + "/" + node_name
		
		# Check if node exists
		if _builder.has_node(full_path):
			var node = _builder.get_node(full_path)
			
			# If node is not parentable, remove it from blueprint
			if not _is_parentable_node(node):
				TreeDebug.msg("Node \"" + full_path + "\" exists and is not a container - removing from blueprint")
				node_data.erase("name")  # This effectively removes this node from processing
				return
			else:
				TreeDebug.msg("Node \"" + full_path + "\" exists but is a container, keeping in blueprint")
	
	# Process children recursively
	var children = node_data.get("children", [])
	if children.is_empty():
		return
	
	var children_to_remove: Array[int] = []
	
	for i in range(children.size()):
		var child_data = children[i]
		var child_name = child_data.get("name", "")
		
		if not child_name.is_empty():
			var child_full_path = parent_path + "/" + node_name + "/" + child_name
			
			if _builder.has_node(child_full_path):
				var child_node = _builder.get_node(child_full_path)
				
				if not _is_parentable_node(child_node):
					TreeDebug.msg("Child node \"" + child_full_path + "\" exists and is not a container - marking for removal")
					children_to_remove.append(i)
					continue
		
		# Recursively check this child's children
		var child_path = parent_path + "/" + node_name if not node_name.is_empty() else parent_path
		throw_out_existing_non_container_nodes(child_path, child_data)
	
	# Remove marked children in reverse order to maintain indices
	children_to_remove.reverse()
	for idx in children_to_remove:
		children.remove_at(idx)
		TreeDebug.msg("Removed child at index " + str(idx) + " from blueprint")

func _is_parentable_node(node: AnimationNode) -> bool:
	return node is AnimationNodeStateMachine or node is AnimationNodeBlendTree or node is AnimationNodeBlendSpace1D or node is AnimationNodeBlendSpace2D

func _collect_existing_nodes(parent_path: String, node_data: Dictionary, existing: Array[String]) -> void:
	var node_name = node_data.get("name", "")
	if not node_name.is_empty():
		
		var full_path = parent_path + "/" + node_name
		TreeDebug.msg("Check if \"" + full_path + "\" exists.")
		
		if _builder.has_node(full_path):
			var node = _builder.get_node(full_path)
			if _is_parentable_node(node):
				TreeDebug.msg("Node \"" + full_path + "\" exists but is parentable, skipping error")
			else:
				existing.append(full_path)
		
		# Check children recursively
		var children = node_data.get("children", [])
		TreeDebug.msg("Check children recursively")
		for child_data in children:
			_collect_existing_nodes(full_path, child_data, existing)

func _validate_animations(animation_tree: AnimationTree, node_data: Dictionary) -> bool:
	var anim_player = _get_animation_player(animation_tree)
	
	if animation_tree == null:
		_add_error("AnimationTree was null")
		return false
	
	if anim_player == null:
		_add_error("AnimationTree has no AnimationPlayer assigned")
		return false
	
	var missing_animations: Array[String] = []
	_collect_missing_animations(node_data, anim_player, missing_animations)
	
	if not missing_animations.is_empty():
		_add_error("Missing animations in AnimationPlayer:")
		for anim_name in missing_animations:
			_add_error("  - " + anim_name)
		return false
	
	TreeDebug.msg("All animations validated successfully")
	return true

func _collect_missing_animations(node_data: Dictionary, anim_player: AnimationPlayer, missing: Array[String]) -> void:
	# Check if this node has an animation
	var animation = node_data.get("animation", "")
	if not animation.is_empty():
		if not anim_player.has_animation(animation):
			if animation not in missing:
				missing.append(animation)
	
	# Check children recursively
	var children = node_data.get("children", [])
	for child_data in children:
		_collect_missing_animations(child_data, anim_player, missing)

func _get_animation_player(animation_tree: AnimationTree) -> AnimationPlayer:
	if animation_tree.anim_player != NodePath():
		var node = animation_tree.get_node(animation_tree.anim_player)
		if node is AnimationPlayer:
			return node as AnimationPlayer
	return null

func get_errors() -> Array[String]:
	return _errors

# ============================================================================
# BUILDING (modified for circular positioning)
# ============================================================================

func _build_node(parent_path: String, node_data: Dictionary, parent_node: AnimationNode = null) -> bool:
	var node_name = node_data.get("name", "")
	var node_type = node_data.get("type", "Animation")
	var animation = node_data.get("animation", "")
	var children = node_data.get("children", [])
	var transitions = node_data.get("transitions", [])
	var connections = node_data.get("connections", [])  # Add this line
	# Extract additional properties
	var properties = {}
	for key in node_data:
		if key not in ["name", "type", "animation", "children", "transitions", "connections", "path"]:  # Add "connections" here
			properties[key] = node_data[key]
	
	TreeDebug.msg("Building node: " + node_name + " (" + node_type + ") at " + parent_path)
	
	# Check if node already exists
	var full_path = parent_path + "/" + node_name
	var node_already_exists = _builder.has_node(full_path)
	var existing_node: AnimationNode = null
	
	if node_already_exists:
		existing_node = _builder.get_node(full_path)
		if _is_parentable_node(existing_node):
			TreeDebug.msg("Node \"" + full_path + "\" already exists and is parentable, reusing it")
		else:
			_add_error("Node already exists and is not parentable: " + node_name)
			return false
	
	# Calculate circular position for this node
	var position = Vector2.ZERO
	if _level_counters.has(parent_path) and _level_totals.has(parent_path):
		var current_index = _level_counters[parent_path]
		var total_siblings = _level_totals[parent_path]
		var center = _get_center_position_for_parent(parent_path)
		
		position = _calculate_circular_position(parent_path, current_index, total_siblings, center)
		_level_counters[parent_path] += 1
		
		TreeDebug.msg("Positioning " + node_name + " at index " + str(current_index) + "/" + str(total_siblings) + " -> " + str(position))
	
	# Check if parent is a BlendSpace
	if parent_node == null:
		parent_node = _builder.get_node(parent_path)
	var parent_is_blendspace = parent_node is AnimationNodeBlendSpace1D or parent_node is AnimationNodeBlendSpace2D
	
	# For BlendSpace parents, get direct reference to the added node
	var created_node: AnimationNode = null
	
	if not node_already_exists:
		# Build node configuration
		var config = {
			"type": node_type,
			"name": node_name,
			"position": position
		}
		
		# Add animation if specified
		if not animation.is_empty():
			config["animation"] = animation
		
		# Add additional properties
		if not properties.is_empty():
			config["properties"] = properties
		
		if parent_is_blendspace:
			if not node_name.is_valid_int():
				_add_error("BlendSpace children must have numeric names, got: " + node_name)
				return false
		# Create the node
		if not _builder.add_node(parent_path, config):
			_add_error("Failed to create node: " + node_name)
			return false
			
		if parent_is_blendspace:
			created_node = _builder.get_last_blend_point_node(parent_path)
			if not is_instance_valid(created_node):
				_add_error("Failed to get blend point node: " + node_name)
				return false
	else:
		created_node = existing_node
	
	# Build child nodes recursively
	for child_data in children:
		if parent_is_blendspace:
			# Use direct node reference for BlendSpace children
			if not _build_node_direct(created_node, child_data):
				return false
		else:
			# Use path-based approach for normal containers
			var node_path = parent_path + "/" + node_name
			if not _build_node(node_path, child_data):
				return false
	
	# Build transitions if this is a StateMachine
	if (node_type == "StateMachine" or node_type == "AnimationNodeStateMachine") and not transitions.is_empty():
		TreeDebug.msg("Building " + str(transitions.size()) + " transitions")
		for transition_data in transitions:
			if parent_is_blendspace:
				if not _build_transition_direct(created_node, transition_data):
					return false
			else:
				var node_path = parent_path + "/" + node_name
				if not _build_transition(node_path, transition_data):
					return false
	
	# Build connections if this is a BlendTree (ADD THIS SECTION)
	if (node_type == "BlendTree" or node_type == "AnimationNodeBlendTree") and not connections.is_empty():
		TreeDebug.msg("Building " + str(connections.size()) + " connections for " + node_name)
		var node_path = parent_path + "/" + node_name
		if not _build_connections(node_path, connections):
			return false
	
	return true


func _build_node_direct(parent_node: AnimationNode, node_data: Dictionary) -> bool:
	var node_name = node_data.get("name", "")
	var node_type = node_data.get("type", "Animation")
	var animation = node_data.get("animation", "")
	var children = node_data.get("children", [])
	var transitions = node_data.get("transitions", [])
	
	# Extract additional properties
	var properties = {}
	for key in node_data:
		if key not in ["name", "type", "animation", "children", "transitions", "path"]:
			properties[key] = node_data[key]
	
	TreeDebug.msg("Building node direct: " + node_name + " (" + node_type + ")")
	
	# Create node instance
	var node: AnimationNode = null
	match node_type:
		"Animation", "AnimationNodeAnimation":
			node = AnimationNodeAnimation.new()
			if not animation.is_empty():
				node.animation = animation
		"StateMachine", "AnimationNodeStateMachine":
			node = AnimationNodeStateMachine.new()
		"BlendTree", "AnimationNodeBlendTree":
			node = AnimationNodeBlendTree.new()
		"BlendSpace1D", "AnimationNodeBlendSpace1D":
			node = AnimationNodeBlendSpace1D.new()
		"BlendSpace2D", "AnimationNodeBlendSpace2D":
			node = AnimationNodeBlendSpace2D.new()
		"OneShot", "AnimationNodeOneShot":
			node = AnimationNodeOneShot.new()
		"Blend2", "AnimationNodeBlend2":
			node = AnimationNodeBlend2.new()
		"Blend3", "AnimationNodeBlend3":
			node = AnimationNodeBlend3.new()
		"TimeScale", "AnimationNodeTimeScale":
			node = AnimationNodeTimeScale.new()
		"TimeSeek", "AnimationNodeTimeSeek":
			node = AnimationNodeTimeSeek.new()
		"Transition", "AnimationNodeTransition":
			node = AnimationNodeTransition.new()
	
	if not is_instance_valid(node):
		_add_error("Failed to create node: " + node_name)
		return false
	
	# Apply properties
	if not properties.is_empty():
		for key in properties:
			if key in node and key != "blend_position":
				node.set(key, properties[key])
	
	# Extract blend_position for BlendSpace parents
	var blend_position = null
	if properties.has("blend_position"):
		var bp = properties["blend_position"]
		if bp is Dictionary:
			if bp.has("x") and bp.has("y"):
				blend_position = Vector2(bp["x"], bp["y"])
			elif bp.has("x"):
				blend_position = bp["x"]
		elif bp is Vector2:
			blend_position = bp
		elif bp is float or bp is int:
			blend_position = float(bp)
	
	# Add node to parent
	if parent_node is AnimationNodeStateMachine:
		var sm = parent_node as AnimationNodeStateMachine
		var pos = Vector2(100, 100)
		sm.add_node(node_name, node, pos)
	elif parent_node is AnimationNodeBlendTree:
		var bt = parent_node as AnimationNodeBlendTree
		var pos = Vector2(100, 100)
		bt.add_node(node_name, node, pos)
	elif parent_node is AnimationNodeBlendSpace1D:
		var bs1d = parent_node as AnimationNodeBlendSpace1D
		var pos_1d: float = 0.0
		if blend_position is float or blend_position is int:
			pos_1d = float(blend_position)
		elif blend_position is Vector2:
			pos_1d = (blend_position as Vector2).x
		bs1d.add_blend_point(node, pos_1d)
	elif parent_node is AnimationNodeBlendSpace2D:
		var bs2d = parent_node as AnimationNodeBlendSpace2D
		var pos_2d: Vector2 = Vector2.ZERO
		if blend_position is Vector2:
			pos_2d = blend_position as Vector2
		elif blend_position is float or blend_position is int:
			pos_2d = Vector2(float(blend_position), 0.0)
		bs2d.add_blend_point(node, pos_2d)
	else:
		_add_error("Cannot add to parent node type")
		return false
	
	# Build children recursively
	for child_data in children:
		if not _build_node_direct(node, child_data):
			return false
	
	# Build transitions if StateMachine
	if node is AnimationNodeStateMachine and not transitions.is_empty():
		TreeDebug.msg("Building " + str(transitions.size()) + " transitions direct")
		for transition_data in transitions:
			if not _build_transition_direct(node, transition_data):
				return false
	
	return true

func _build_transition_direct(state_machine: AnimationNode, transition_data: Dictionary) -> bool:
	if not state_machine is AnimationNodeStateMachine:
		_add_error("Not a StateMachine")
		return false
	
	var sm = state_machine as AnimationNodeStateMachine
	var from_state = transition_data.get("from", "")
	var to_state = transition_data.get("to", "")
	
	if from_state.is_empty() or to_state.is_empty():
		_add_error("Transition missing 'from' or 'to' state")
		return false
	
	TreeDebug.msg("Building transition direct: " + from_state + " -> " + to_state)
	
	var trans = AnimationNodeStateMachineTransition.new()
	
	if transition_data.has("switch_mode"):
		match transition_data["switch_mode"]:
			"immediate":
				trans.switch_mode = AnimationNodeStateMachineTransition.SWITCH_MODE_IMMEDIATE
			"sync":
				trans.switch_mode = AnimationNodeStateMachineTransition.SWITCH_MODE_SYNC
			"at_end":
				trans.switch_mode = AnimationNodeStateMachineTransition.SWITCH_MODE_AT_END
	else:
		trans.switch_mode = AnimationNodeStateMachineTransition.SWITCH_MODE_IMMEDIATE
	
	if transition_data.has("advance_mode"):
		if transition_data["advance_mode"] == true:
			trans.advance_mode = AnimationNodeStateMachineTransition.ADVANCE_MODE_AUTO
		else:
			trans.advance_mode = AnimationNodeStateMachineTransition.ADVANCE_MODE_ENABLED
	else:
		trans.advance_mode = AnimationNodeStateMachineTransition.ADVANCE_MODE_AUTO
	
	if transition_data.has("condition"):
		trans.advance_condition = transition_data["condition"]
	
	if transition_data.has("expression"):
		trans.advance_expression = transition_data["expression"]
	
	trans.xfade_time = transition_data.get("xfade_time", transition_data.get("fade_time", 0.0))
	trans.priority = transition_data.get("priority", 1)
	trans.reset = transition_data.get("reset", true)
	
	if transition_data.has("xfade_curve"):
		trans.xfade_curve = transition_data["xfade_curve"]
	elif transition_data.has("curve"):
		trans.xfade_curve = transition_data["curve"]
	
	sm.add_transition(from_state, to_state, trans)
	
	return true

func _build_transition(state_machine_path: String, transition_data: Dictionary) -> bool:
	var from_state = transition_data.get("from", "")
	var to_state = transition_data.get("to", "")
	
	if from_state.is_empty() or to_state.is_empty():
		_add_error("Transition missing 'from' or 'to' state")
		return false
	
	TreeDebug.msg("Building transition: " + from_state + " -> " + to_state)
	
	# Build transition configuration
	var config = {
		"from": from_state,
		"to": to_state
	}
	
	# Copy all properties except 'from' and 'to'
	for key in transition_data:
		if key not in ["from", "to"]:
			config[key] = transition_data[key]
	
	# Create the transition
	if not _builder.add_transition(state_machine_path, config):
		_add_error("Failed to create transition" + from_state + " -> " + to_state)
		return false
	
	return true

# ============================================================================
# CONNECTION BUILDING
# ============================================================================

func _build_connections(blendtree_path: String, connections: Array) -> bool:
	var success = true
	var connection_count = 0
	
	for connection_data in connections:
		if not connection_data is Dictionary:
			_add_error("Connection must be a Dictionary")
			success = false
			continue
		
		if not connection_data.has("from") or not connection_data.has("to"):
			_add_error("Connection must have 'from' and 'to' fields")
			success = false
			continue
		
		var from_node = connection_data["from"]
		var to_node = connection_data["to"]
		var to_input = connection_data.get("to_input", connection_data.get("input_index", 0))
		
		var input_display = str(to_input) if to_input is int else "'" + to_input + "'"
		TreeDebug.msg("Building connection: " + from_node + " -> " + to_node + "." + input_display)
		
		if not _builder.add_connection(blendtree_path, connection_data):
			_add_error("Failed to create connection: " + from_node + " -> " + to_node)
			success = false
		else:
			connection_count += 1
	
	TreeDebug.msg("Built " + str(connection_count) + "/" + str(connections.size()) + " connections")
	return success
	
func _add_error(message: String) -> void:
	_errors.append(message)
