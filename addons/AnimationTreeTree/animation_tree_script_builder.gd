# spinalcord
# https://github.com/spinalcord/animation-tree-tree-godot
# 
# This file is part of animation-tree-tree-godot.
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public.
#
# NOTE: The output generated by this addon is not affected by this license.

class_name AnimationTreeScriptBuilder
extends RefCounted

var _builder: AnimationTreeBuilder
var _yaml_parser: YamlDeserializer
var _errors: Array[String] = []

# Track positioning data for circular arrangement
var _level_counters: Dictionary = {}  # path -> counter for each level
var _level_totals: Dictionary = {}    # path -> total children count

func _init():
	_yaml_parser = YamlDeserializer.new()

# ============================================================================
# PUBLIC API
# ============================================================================

func build_from_script(animation_tree: AnimationTree, script_text: String) -> bool:
	_builder = AnimationTreeBuilder.new(animation_tree)
	_errors.clear()
	_level_counters.clear()
	_level_totals.clear()
	
	# Parse YAML
	var parsed = _yaml_parser.from_text(script_text)
	if parsed == null:
		_add_error("Failed to parse YAML script")
		return false
	
	if not parsed.has("target_path"):
		_add_error("Script must specify 'target_path'")
		return false
	
	var target_path = parsed["target_path"]
	var blueprint = parsed.get("Blueprint", {})
	
	if blueprint.is_empty():
		_add_error("Script must specify 'Blueprint' node")
		return false
	
	TreeDebug.msg("=== Building from YAML script ===")
	TreeDebug.msg("Target path: " + target_path)
	TreeDebug.msg("Building root node: " + str(blueprint.get("name", "unnamed")))
	# Pre-calculate children counts for circular positioning
	_precalculate_children_counts(target_path, blueprint)
	# Validate nodes don't already exist
	if not _validate_nodes_dont_exist(target_path, blueprint):
		_add_error("ERROR: Build aborted due to existing nodes")
	# Validate all animations exist BEFORE building
	if not _validate_animations(animation_tree, blueprint):
		_add_error("ERROR: Build aborted due to missing animations. Checkout your blueprint")
	
	if _errors.size() > 0:
		var error_message = ""
		for err in _errors:
			TreeDebug.msg("ERROR: " + err)
			error_message += err + "\n"
		TreeDebug.msg(error_message.strip_edges(), true)
		return false
	
	# Build the root node
	if not _build_node(target_path, blueprint):
		return false
	
	TreeDebug.msg("=== Build completed successfully ===")
	return true

# ============================================================================
# CIRCULAR POSITIONING
# ============================================================================

func _precalculate_children_counts(parent_path: String, node_data: Dictionary) -> void:
	var node_name = node_data.get("name", "")
	var children = node_data.get("children", [])
	
	if not node_name.is_empty():
		var node_path = parent_path + "/" + node_name
		_level_totals[node_path] = children.size()
		_level_counters[node_path] = 0
		
		# Recursively calculate for children
		for child_data in children:
			_precalculate_children_counts(node_path, child_data)

func _calculate_circular_position(parent_path: String, index: int, total: int, center: Vector2 = Vector2(300, 300), radius: float = 150.0) -> Vector2:
	if total <= 1:
		return center
	
	# Calculate angle for this position (distribute evenly around circle)
	var angle = 2.0 * PI * float(index) / float(total)
	
	# Add slight spiral effect based on level depth
	var level_depth = parent_path.count("/")
	var spiral_offset = level_depth * 20.0  # Each level spirals outward slightly
	var final_radius = radius + spiral_offset
	
	# Calculate position
	var x = center.x + cos(angle) * final_radius
	var y = center.y + sin(angle) * final_radius
	
	return Vector2(x, y)

func _get_center_position_for_parent(parent_path: String) -> Vector2:
	# Get center based on parent type and existing content
	var parent_node = _builder.get_node(parent_path)
	
	if parent_node is AnimationNodeStateMachine:
		# For state machines, use existing logic but with circular adjustment
		var existing_children = _builder.get_child_names(parent_path)
		if existing_children.is_empty():
			return Vector2(300, 300)  # Default center
		
		# Calculate center of existing nodes
		var center = Vector2.ZERO
		var count = 0
		for child_name in existing_children:
			var pos = _builder.get_node_position(parent_path + "/" + child_name)
			center += pos
			count += 1
		
		return center / count if count > 0 else Vector2(300, 300)
	
	elif parent_node is AnimationNodeBlendTree:
		# For blend trees, position more compactly
		return Vector2(200, 200)
	
	return Vector2(300, 300)  # Default fallback

# ============================================================================
# VALIDATION (unchanged)
# ============================================================================

func _validate_nodes_dont_exist(target_path: String, node_data: Dictionary) -> bool:
	var existing_nodes: Array[String] = []
	_collect_existing_nodes(target_path, node_data, existing_nodes)
	
	if not existing_nodes.is_empty():
		_add_error("Nodes already exist at target path:")
		for node_name in existing_nodes:
			_add_error("  - " + node_name)
		return false
	
	TreeDebug.msg("All nodes validated as non-existing")
	return true

func _collect_existing_nodes(parent_path: String, node_data: Dictionary, existing: Array[String]) -> void:
	var node_name = node_data.get("name", "")
	if not node_name.is_empty():
		
		var full_path = parent_path + "/" + node_name
		TreeDebug.msg("Check if \"" + full_path + "\" exists.")
		
		if _builder.has_node(full_path):
			existing.append(full_path)
		
		# Check children recursively
		var children = node_data.get("children", [])
		TreeDebug.msg("Check children recursively")
		for child_data in children:
			_collect_existing_nodes(full_path, child_data, existing)

func _validate_animations(animation_tree: AnimationTree, node_data: Dictionary) -> bool:
	var anim_player = _get_animation_player(animation_tree)
	if anim_player == null:
		_add_error("AnimationTree has no AnimationPlayer assigned")
		return false
	
	var missing_animations: Array[String] = []
	_collect_missing_animations(node_data, anim_player, missing_animations)
	
	if not missing_animations.is_empty():
		_add_error("Missing animations in AnimationPlayer:")
		for anim_name in missing_animations:
			_add_error("  - " + anim_name)
		return false
	
	TreeDebug.msg("All animations validated successfully")
	return true

func _collect_missing_animations(node_data: Dictionary, anim_player: AnimationPlayer, missing: Array[String]) -> void:
	# Check if this node has an animation
	var animation = node_data.get("animation", "")
	if not animation.is_empty():
		if not anim_player.has_animation(animation):
			if animation not in missing:
				missing.append(animation)
	
	# Check children recursively
	var children = node_data.get("children", [])
	for child_data in children:
		_collect_missing_animations(child_data, anim_player, missing)

func _get_animation_player(animation_tree: AnimationTree) -> AnimationPlayer:
	if animation_tree.anim_player != NodePath():
		var node = animation_tree.get_node(animation_tree.anim_player)
		if node is AnimationPlayer:
			return node as AnimationPlayer
	return null

func get_errors() -> Array[String]:
	return _errors

# ============================================================================
# BUILDING (modified for circular positioning)
# ============================================================================

func _build_node(parent_path: String, node_data: Dictionary) -> bool:
	var node_name = node_data.get("name", "")
	var node_type = node_data.get("type", "Animation")
	var animation = node_data.get("animation", "")
	var children = node_data.get("children", [])
	var transitions = node_data.get("transitions", [])
	
	# Extract additional properties
	var properties = {}
	for key in node_data:
		if key not in ["name", "type", "animation", "children", "transitions", "path"]:
			properties[key] = node_data[key]
	
	TreeDebug.msg("Building node: " + node_name + " (" + node_type + ") at " + parent_path)
	
	# Calculate circular position for this node
	var position = Vector2.ZERO
	if _level_counters.has(parent_path) and _level_totals.has(parent_path):
		var current_index = _level_counters[parent_path]
		var total_siblings = _level_totals[parent_path]
		var center = _get_center_position_for_parent(parent_path)
		
		position = _calculate_circular_position(parent_path, current_index, total_siblings, center)
		_level_counters[parent_path] += 1
		
		TreeDebug.msg("Positioning " + node_name + " at index " + str(current_index) + "/" + str(total_siblings) + " -> " + str(position))
	
	# Build node configuration
	var config = {
		"type": node_type,
		"name": node_name,
		"position": position  # Add calculated position
	}
	
	# Add animation if specified
	if not animation.is_empty():
		config["animation"] = animation
	
	# Add additional properties
	if not properties.is_empty():
		config["properties"] = properties
	
	# Create the node
	if not _builder.add_node(parent_path, config):
		_add_error("Failed to create node: " + node_name )
		return false
	
	# Build the full path for this node
	var node_path = parent_path + "/" + node_name
	
	# Build child nodes recursively
	for child_data in children:
		if not _build_node(node_path, child_data):
			return false
	
	# Build transitions if this is a StateMachine
	if (node_type == "StateMachine" or node_type == "AnimationNodeStateMachine") and not transitions.is_empty():
		TreeDebug.msg("Building " + str(transitions.size()) + " transitions for " + node_path)
		for transition_data in transitions:
			if not _build_transition(node_path, transition_data):
				return false
	
	return true

func _build_transition(state_machine_path: String, transition_data: Dictionary) -> bool:
	var from_state = transition_data.get("from", "")
	var to_state = transition_data.get("to", "")
	
	if from_state.is_empty() or to_state.is_empty():
		_add_error("Transition missing 'from' or 'to' state")
		return false
	
	TreeDebug.msg("Building transition: " + from_state + " -> " + to_state)
	
	# Build transition configuration
	var config = {
		"from": from_state,
		"to": to_state
	}
	
	# Copy all properties except 'from' and 'to'
	for key in transition_data:
		if key not in ["from", "to"]:
			config[key] = transition_data[key]
	
	# Create the transition
	if not _builder.add_transition(state_machine_path, config):
		_add_error("Failed to create transition" + from_state + " -> " + to_state)
		return false
	
	return true

func _add_error(message: String) -> void:
	_errors.append(message)
