# spinalcord
# https://github.com/spinalcord/animation-tree-tree-godot
# 
# This file is part of animation-tree-tree-godot.
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public.
#
# NOTE: The output generated by this addon is not affected by this license.

class_name AnimationTreeScriptBuilder
extends RefCounted

var _builder: AnimationTreeBuilder
var _yaml_parser: YamlDeserializer
var _errors: Array[String] = []

# Track positioning data for circular arrangement
var _level_counters: Dictionary = {}  # path -> counter for each level
var _level_totals: Dictionary = {}    # path -> total children count

func _init():
	_yaml_parser = YamlDeserializer.new()

# ============================================================================
# PUBLIC API
# ============================================================================

func build_from_script(animation_tree: AnimationTree, script_text: String) -> bool:
	_builder = AnimationTreeBuilder.new(animation_tree)
	_errors.clear()
	_level_counters.clear()
	_level_totals.clear()
	
	# Parse YAML
	var parsed = _yaml_parser.from_text(script_text)
	if parsed == null:
		_add_error("Failed to parse YAML script")
		return false
	
	if not parsed.has("target_path"):
		_add_error("Script must specify 'target_path'")
		return false
	
	var target_path = parsed["target_path"]
	var blueprint = parsed.get("Blueprint", {})
	
	if blueprint.is_empty():
		_add_error("Script must specify 'Blueprint' node")
		return false
	
	TreeDebug.msg("=== Building from YAML script ===")
	TreeDebug.msg("Target path: " + target_path)
	TreeDebug.msg("Building root node: " + str(blueprint.get("name", "unnamed")))
	# Pre-calculate children counts for circular positioning
	_precalculate_children_counts(target_path, blueprint)
	# Validate nodes don't already exist
	if not _validate_nodes_dont_exist(target_path, blueprint):
		_add_error("ERROR: Build aborted due to existing nodes")
	# Validate all animations exist BEFORE building
	if not _validate_animations(animation_tree, blueprint):
		_add_error("ERROR: Build aborted due to missing animations. Checkout your blueprint")
	
	if _errors.size() > 0:
		var error_message = ""
		for err in _errors:
			TreeDebug.msg("ERROR: " + err)
			error_message += err + "\n"
		TreeDebug.msg(error_message.strip_edges(), true)
		return false
	
	# Build the root node
	if not _build_node(target_path, blueprint):
		return false
	
	TreeDebug.msg("=== Build completed successfully ===")
	return true

# ============================================================================
# CIRCULAR POSITIONING
# ============================================================================

func _precalculate_children_counts(parent_path: String, node_data: Dictionary) -> void:
	var node_name = node_data.get("name", "")
	var children = node_data.get("children", [])
	
	if not node_name.is_empty():
		var node_path = parent_path + "/" + node_name
		_level_totals[node_path] = children.size()
		_level_counters[node_path] = 0
		
		# Recursively calculate for children
		for child_data in children:
			_precalculate_children_counts(node_path, child_data)

func _calculate_circular_position(parent_path: String, index: int, total: int, center: Vector2 = Vector2(300, 300), radius: float = 150.0) -> Vector2:
	if total <= 1:
		return center
	
	# Calculate angle for this position (distribute evenly around circle)
	var angle = 2.0 * PI * float(index) / float(total)
	
	# Add slight spiral effect based on level depth
	var level_depth = parent_path.count("/")
	var spiral_offset = level_depth * 20.0  # Each level spirals outward slightly
	var final_radius = radius + spiral_offset
	
	# Calculate position
	var x = center.x + cos(angle) * final_radius
	var y = center.y + sin(angle) * final_radius
	
	return Vector2(x, y)

func _get_center_position_for_parent(parent_path: String) -> Vector2:
	# Get center based on parent type and existing content
	var parent_node = _builder.get_node(parent_path)
	
	if parent_node is AnimationNodeStateMachine:
		# For state machines, use existing logic but with circular adjustment
		var existing_children = _builder.get_child_names(parent_path)
		if existing_children.is_empty():
			return Vector2(300, 300)  # Default center
		
		# Calculate center of existing nodes
		var center = Vector2.ZERO
		var count = 0
		for child_name in existing_children:
			var pos = _builder.get_node_position(parent_path + "/" + child_name)
			center += pos
			count += 1
		
		return center / count if count > 0 else Vector2(300, 300)
	
	elif parent_node is AnimationNodeBlendTree:
		# For blend trees, position more compactly
		return Vector2(200, 200)
	
	return Vector2(300, 300)  # Default fallback

# ============================================================================
# VALIDATION (unchanged)
# ============================================================================

func _validate_nodes_dont_exist(target_path: String, node_data: Dictionary) -> bool:
	var existing_nodes: Array[String] = []
	_collect_existing_nodes(target_path, node_data, existing_nodes)
	
	if not existing_nodes.is_empty():
		_add_error("Nodes already exist at target path:")
		for node_name in existing_nodes:
			_add_error("  - " + node_name)
		return false
	
	TreeDebug.msg("All nodes validated as non-existing")
	return true

func _collect_existing_nodes(parent_path: String, node_data: Dictionary, existing: Array[String]) -> void:
	var node_name = node_data.get("name", "")
	if not node_name.is_empty():
		
		var full_path = parent_path + "/" + node_name
		TreeDebug.msg("Check if \"" + full_path + "\" exists.")
		
		if _builder.has_node(full_path):
			existing.append(full_path)
		
		# Check children recursively
		var children = node_data.get("children", [])
		TreeDebug.msg("Check children recursively")
		for child_data in children:
			_collect_existing_nodes(full_path, child_data, existing)

func _validate_animations(animation_tree: AnimationTree, node_data: Dictionary) -> bool:
	var anim_player = _get_animation_player(animation_tree)
	if anim_player == null:
		_add_error("AnimationTree has no AnimationPlayer assigned")
		return false
	
	var missing_animations: Array[String] = []
	_collect_missing_animations(node_data, anim_player, missing_animations)
	
	if not missing_animations.is_empty():
		_add_error("Missing animations in AnimationPlayer:")
		for anim_name in missing_animations:
			_add_error("  - " + anim_name)
		return false
	
	TreeDebug.msg("All animations validated successfully")
	return true

func _collect_missing_animations(node_data: Dictionary, anim_player: AnimationPlayer, missing: Array[String]) -> void:
	# Check if this node has an animation
	var animation = node_data.get("animation", "")
	if not animation.is_empty():
		if not anim_player.has_animation(animation):
			if animation not in missing:
				missing.append(animation)
	
	# Check children recursively
	var children = node_data.get("children", [])
	for child_data in children:
		_collect_missing_animations(child_data, anim_player, missing)

func _get_animation_player(animation_tree: AnimationTree) -> AnimationPlayer:
	if animation_tree.anim_player != NodePath():
		var node = animation_tree.get_node(animation_tree.anim_player)
		if node is AnimationPlayer:
			return node as AnimationPlayer
	return null

func get_errors() -> Array[String]:
	return _errors

# ============================================================================
# BUILDING (modified for circular positioning)
# ============================================================================


func _build_node(parent_path: String, node_data: Dictionary, parent_node: AnimationNode = null) -> bool:
	var node_name = node_data.get("name", "")
	var node_type = node_data.get("type", "Animation")
	var animation = node_data.get("animation", "")
	var children = node_data.get("children", [])
	var transitions = node_data.get("transitions", [])
	
	# Extract additional properties
	var properties = {}
	for key in node_data:
		if key not in ["name", "type", "animation", "children", "transitions", "path"]:
			properties[key] = node_data[key]
	
	TreeDebug.msg("Building node: " + node_name + " (" + node_type + ") at " + parent_path)
	
	# Calculate circular position for this node
	var position = Vector2.ZERO
	if _level_counters.has(parent_path) and _level_totals.has(parent_path):
		var current_index = _level_counters[parent_path]
		var total_siblings = _level_totals[parent_path]
		var center = _get_center_position_for_parent(parent_path)
		
		position = _calculate_circular_position(parent_path, current_index, total_siblings, center)
		_level_counters[parent_path] += 1
		
		TreeDebug.msg("Positioning " + node_name + " at index " + str(current_index) + "/" + str(total_siblings) + " -> " + str(position))
	
	# Check if parent is a BlendSpace
	if parent_node == null:
		parent_node = _builder.get_node(parent_path)
	var parent_is_blendspace = parent_node is AnimationNodeBlendSpace1D or parent_node is AnimationNodeBlendSpace2D
	
	# Build node configuration
	var config = {
		"type": node_type,
		"name": node_name,
		"position": position
	}
	
	# Add animation if specified
	if not animation.is_empty():
		config["animation"] = animation
	
	# Add additional properties
	if not properties.is_empty():
		config["properties"] = properties
	
	if parent_is_blendspace:
		if not node_name.is_valid_int():
			_add_error("BlendSpace children must have numeric names, got: " + node_name)
			return false
	
	# Create the node
	if not _builder.add_node(parent_path, config):
		_add_error("Failed to create node: " + node_name)
		return false
	
	# For BlendSpace parents, get direct reference to the added node
	var created_node: AnimationNode = null
	if parent_is_blendspace:
		created_node = _builder.get_last_blend_point_node(parent_path)
		if not is_instance_valid(created_node):
			_add_error("Failed to get blend point node: " + node_name)
			return false
	
	# Build child nodes recursively
	for child_data in children:
		if parent_is_blendspace:
			# Use direct node reference for BlendSpace children
			if not _build_node_direct(created_node, child_data):
				return false
		else:
			# Use path-based approach for normal containers
			var node_path = parent_path + "/" + node_name
			if not _build_node(node_path, child_data):
				return false
	
	# Build transitions if this is a StateMachine
	if (node_type == "StateMachine" or node_type == "AnimationNodeStateMachine") and not transitions.is_empty():
		TreeDebug.msg("Building " + str(transitions.size()) + " transitions")
		for transition_data in transitions:
			if parent_is_blendspace:
				if not _build_transition_direct(created_node, transition_data):
					return false
			else:
				var node_path = parent_path + "/" + node_name
				if not _build_transition(node_path, transition_data):
					return false
	
	return true

func _build_node_direct(parent_node: AnimationNode, node_data: Dictionary) -> bool:
	var node_name = node_data.get("name", "")
	var node_type = node_data.get("type", "Animation")
	var animation = node_data.get("animation", "")
	var children = node_data.get("children", [])
	var transitions = node_data.get("transitions", [])
	
	# Extract additional properties
	var properties = {}
	for key in node_data:
		if key not in ["name", "type", "animation", "children", "transitions", "path"]:
			properties[key] = node_data[key]
	
	TreeDebug.msg("Building node direct: " + node_name + " (" + node_type + ")")
	
	# Create node instance
	var node: AnimationNode = null
	match node_type:
		"Animation", "AnimationNodeAnimation":
			node = AnimationNodeAnimation.new()
			if not animation.is_empty():
				node.animation = animation
		"StateMachine", "AnimationNodeStateMachine":
			node = AnimationNodeStateMachine.new()
		"BlendTree", "AnimationNodeBlendTree":
			node = AnimationNodeBlendTree.new()
		"BlendSpace1D", "AnimationNodeBlendSpace1D":
			node = AnimationNodeBlendSpace1D.new()
		"BlendSpace2D", "AnimationNodeBlendSpace2D":
			node = AnimationNodeBlendSpace2D.new()
		"OneShot", "AnimationNodeOneShot":
			node = AnimationNodeOneShot.new()
		"Blend2", "AnimationNodeBlend2":
			node = AnimationNodeBlend2.new()
		"Blend3", "AnimationNodeBlend3":
			node = AnimationNodeBlend3.new()
		"TimeScale", "AnimationNodeTimeScale":
			node = AnimationNodeTimeScale.new()
		"TimeSeek", "AnimationNodeTimeSeek":
			node = AnimationNodeTimeSeek.new()
		"Transition", "AnimationNodeTransition":
			node = AnimationNodeTransition.new()
	
	if not is_instance_valid(node):
		_add_error("Failed to create node: " + node_name)
		return false
	
	# Apply properties
	if not properties.is_empty():
		for key in properties:
			if key in node and key != "blend_position":
				node.set(key, properties[key])
	
	# Extract blend_position for BlendSpace parents
	var blend_position = null
	if properties.has("blend_position"):
		var bp = properties["blend_position"]
		if bp is Dictionary:
			if bp.has("x") and bp.has("y"):
				blend_position = Vector2(bp["x"], bp["y"])
			elif bp.has("x"):
				blend_position = bp["x"]
		elif bp is Vector2:
			blend_position = bp
		elif bp is float or bp is int:
			blend_position = float(bp)
	
	# Add node to parent
	if parent_node is AnimationNodeStateMachine:
		var sm = parent_node as AnimationNodeStateMachine
		var pos = Vector2(100, 100)
		sm.add_node(node_name, node, pos)
	elif parent_node is AnimationNodeBlendTree:
		var bt = parent_node as AnimationNodeBlendTree
		var pos = Vector2(100, 100)
		bt.add_node(node_name, node, pos)
	elif parent_node is AnimationNodeBlendSpace1D:
		var bs1d = parent_node as AnimationNodeBlendSpace1D
		var pos_1d: float = 0.0
		if blend_position is float or blend_position is int:
			pos_1d = float(blend_position)
		elif blend_position is Vector2:
			pos_1d = (blend_position as Vector2).x
		bs1d.add_blend_point(node, pos_1d)
	elif parent_node is AnimationNodeBlendSpace2D:
		var bs2d = parent_node as AnimationNodeBlendSpace2D
		var pos_2d: Vector2 = Vector2.ZERO
		if blend_position is Vector2:
			pos_2d = blend_position as Vector2
		elif blend_position is float or blend_position is int:
			pos_2d = Vector2(float(blend_position), 0.0)
		bs2d.add_blend_point(node, pos_2d)
	else:
		_add_error("Cannot add to parent node type")
		return false
	
	# Build children recursively
	for child_data in children:
		if not _build_node_direct(node, child_data):
			return false
	
	# Build transitions if StateMachine
	if node is AnimationNodeStateMachine and not transitions.is_empty():
		TreeDebug.msg("Building " + str(transitions.size()) + " transitions direct")
		for transition_data in transitions:
			if not _build_transition_direct(node, transition_data):
				return false
	
	return true

func _build_transition_direct(state_machine: AnimationNode, transition_data: Dictionary) -> bool:
	if not state_machine is AnimationNodeStateMachine:
		_add_error("Not a StateMachine")
		return false
	
	var sm = state_machine as AnimationNodeStateMachine
	var from_state = transition_data.get("from", "")
	var to_state = transition_data.get("to", "")
	
	if from_state.is_empty() or to_state.is_empty():
		_add_error("Transition missing 'from' or 'to' state")
		return false
	
	TreeDebug.msg("Building transition direct: " + from_state + " -> " + to_state)
	
	var trans = AnimationNodeStateMachineTransition.new()
	
	if transition_data.has("switch_mode"):
		match transition_data["switch_mode"]:
			"immediate":
				trans.switch_mode = AnimationNodeStateMachineTransition.SWITCH_MODE_IMMEDIATE
			"sync":
				trans.switch_mode = AnimationNodeStateMachineTransition.SWITCH_MODE_SYNC
			"at_end":
				trans.switch_mode = AnimationNodeStateMachineTransition.SWITCH_MODE_AT_END
	else:
		trans.switch_mode = AnimationNodeStateMachineTransition.SWITCH_MODE_IMMEDIATE
	
	if transition_data.has("advance_mode"):
		if transition_data["advance_mode"] == true:
			trans.advance_mode = AnimationNodeStateMachineTransition.ADVANCE_MODE_AUTO
		else:
			trans.advance_mode = AnimationNodeStateMachineTransition.ADVANCE_MODE_ENABLED
	else:
		trans.advance_mode = AnimationNodeStateMachineTransition.ADVANCE_MODE_AUTO
	
	if transition_data.has("condition"):
		trans.advance_condition = transition_data["condition"]
	
	if transition_data.has("expression"):
		trans.advance_expression = transition_data["expression"]
	
	trans.xfade_time = transition_data.get("fade_time", 0.0)
	trans.priority = transition_data.get("priority", 1)
	trans.reset = transition_data.get("reset", true)
	
	if transition_data.has("curve"):
		trans.xfade_curve = transition_data["curve"]
	
	sm.add_transition(from_state, to_state, trans)
	
	return true

func _build_transition(state_machine_path: String, transition_data: Dictionary) -> bool:
	var from_state = transition_data.get("from", "")
	var to_state = transition_data.get("to", "")
	
	if from_state.is_empty() or to_state.is_empty():
		_add_error("Transition missing 'from' or 'to' state")
		return false
	
	TreeDebug.msg("Building transition: " + from_state + " -> " + to_state)
	
	# Build transition configuration
	var config = {
		"from": from_state,
		"to": to_state
	}
	
	# Copy all properties except 'from' and 'to'
	for key in transition_data:
		if key not in ["from", "to"]:
			config[key] = transition_data[key]
	
	# Create the transition
	if not _builder.add_transition(state_machine_path, config):
		_add_error("Failed to create transition" + from_state + " -> " + to_state)
		return false
	
	return true

func _add_error(message: String) -> void:
	_errors.append(message)
