# spinalcord
# https://github.com/spinalcord/animation-tree-tree-godot
# 
# This file is part of animation-tree-tree-godot.
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public.
#
# NOTE: The output generated by this addon is not affected by this license.

class_name BlueprintGenerator

var _serializer: YamlSerializer

func _init():
	_serializer = YamlSerializer.new()

# Main method that produces YAML using YamlSerializer
func format_tree_node_to_yaml(node: AnimationNode, path: String, depth: int, transitions_by_path: Dictionary, selected_paths: Array[String]) -> String:
	var data = _build_tree_structure(node, path, transitions_by_path, selected_paths)
	
	if data.is_empty():
		return ""
	
	var options = YamlSerializer.SerializeOptions.new()
	options.skip_null_values = true
	options.skip_empty_collections = true
	options.pretty_multiline = false
	return _serializer.to_text(data, options)

# Build the data structure as Dictionary/Array
func _build_tree_structure(node: AnimationNode, path: String, transitions_by_path: Dictionary, selected_paths: Array[String]) -> Dictionary:
	var is_selected = selected_paths.is_empty() or _is_path_selected_or_parent(path, selected_paths)
	var has_selected_children = selected_paths.is_empty() or _has_selected_children(path, selected_paths)
	
	if not is_selected and not has_selected_children:
		return {}
	
	var node_data = {}
	
	# Root node (depth 0 / empty path)
	if path.is_empty():
		node_data["name"] = "Root"
		node_data["type"] = node.get_class()
	else:
		var node_name = _get_node_name_from_path(path)
		node_data["name"] = node_name
		node_data["type"] = node.get_class()
		
		# Add animation name if this is an AnimationNodeAnimation
		if node is AnimationNodeAnimation:
			var animation_name = node.animation
			if not animation_name.is_empty():
				node_data["animation"] = animation_name
		
		#node_data["path"] = path # keep this for later ideas
	
	# Build children array
	var children_array = _build_children_array(node, path, transitions_by_path, selected_paths)
	
	if not children_array.is_empty():
		node_data["children"] = children_array
	
	# Add transitions if applicable
	if (is_selected or has_selected_children) and transitions_by_path.has(path):
		var transitions = transitions_by_path[path] as Array
		var filtered_transitions = _filter_transitions_by_selection(transitions, path, selected_paths) if not selected_paths.is_empty() else transitions
		
		if not filtered_transitions.is_empty():
			var transitions_array = _build_transitions_array(filtered_transitions)
			if not transitions_array.is_empty():
				node_data["transitions"] = transitions_array
	
	# Wrap root in Blueprint
	if path.is_empty():
		return {"Blueprint": node_data}
	
	return node_data

func _build_children_array(node: AnimationNode, path: String, transitions_by_path: Dictionary, selected_paths: Array[String]) -> Array:
	var children: Array = []
	
	if node is AnimationNodeStateMachine:
		var state_machine = node as AnimationNodeStateMachine
		var state_names = NodeUtils.get_container_children(state_machine)
		
		for state_name in state_names:
			var child_path = PathUtils.build_child_path(path, state_name)
			var state_node = state_machine.get("states/%s/node" % state_name) as AnimationNode
			if state_node:
				var child_data = _build_tree_structure(state_node, child_path, transitions_by_path, selected_paths)
				if not child_data.is_empty():
					children.append(child_data)
	
	elif node is AnimationNodeBlendTree:
		var blend_tree = node as AnimationNodeBlendTree
		var node_names = NodeUtils.get_container_children(blend_tree)
		
		for node_name in node_names:
			if node_name == "output":
				continue
			var child_path = PathUtils.build_child_path(path, node_name)
			var blend_node = NodeUtils.get_blend_tree_node(blend_tree, node_name)
			if blend_node:
				var child_data = _build_tree_structure(blend_node, child_path, transitions_by_path, selected_paths)
				if not child_data.is_empty():
					children.append(child_data)
	
	return children

func _build_transitions_array(transitions: Array) -> Array:
	var transitions_array: Array = []
	
	for transition_data in transitions:
		if transition_data is Dictionary:
			var trans_dict = {}
			
			trans_dict["from"] = transition_data.get("from", "")
			trans_dict["to"] = transition_data.get("to", "")
			
			var switch_mode = transition_data.get("switch_mode", 0)
			trans_dict["switch_mode"] = get_switch_mode_text(switch_mode)
			
			# Add optional properties
			var condition = transition_data.get("advance_condition", "")
			if not condition.is_empty():
				trans_dict["condition"] = condition
			
			var expression = transition_data.get("advance_expression", "")
			if not expression.is_empty():
				trans_dict["expression"] = expression.strip_edges()
			
			var xfade_time = transition_data.get("xfade_time", 0.0)
			if xfade_time > 0.0:
				trans_dict["fade_time"] = xfade_time
			
			var priority = transition_data.get("priority", 1)
			if priority != 1:
				trans_dict["priority"] = priority
			
			var advance_mode = transition_data.get("advance_mode", 1)
			if advance_mode != 2:
				trans_dict["auto_advance"] = advance_mode == 2
			
			var reset = transition_data.get("reset", false)
			if not reset:
				trans_dict["reset"] = false
			
			transitions_array.append(trans_dict)
	
	return transitions_array

func get_switch_mode_text(switch_mode: int) -> String:
	match switch_mode:
		0: return "immediate"
		1: return "sync"
		2: return "at_end"
		_: return "unknown"

# Check if a path is directly selected or if any parent path is selected
func _is_path_selected_or_parent(path: String, selected_paths: Array[String]) -> bool:
	if path.is_empty():
		return false
	
	if path in selected_paths:
		return true
	
	for selected_path in selected_paths:
		if path.begins_with(selected_path + "/") or path == selected_path:
			return true
	
	return false

# Check if this path has any selected children
func _has_selected_children(path: String, selected_paths: Array[String]) -> bool:
	if path.is_empty():
		return not selected_paths.is_empty()
	
	for selected_path in selected_paths:
		if selected_path.begins_with(path + "/"):
			return true
	return false

# Filter transitions to only include those between selected nodes
func _filter_transitions_by_selection(transitions: Array, current_path: String, selected_paths: Array[String]) -> Array[Dictionary]:
	var filtered: Array[Dictionary] = []
	
	for transition_data in transitions:
		if not transition_data is Dictionary:
			continue
		
		var from = transition_data.get("from", "")
		var to = transition_data.get("to", "")
		
		var is_from_special = from == "Start" or from == "End"
		var is_to_special = to == "Start" or to == "End"
		
		var from_path = current_path + "/" + from if not current_path.is_empty() else from
		var to_path = current_path + "/" + to if not current_path.is_empty() else to
		
		var from_selected = is_from_special or _is_path_selected_or_parent(from_path, selected_paths)
		var to_selected = is_to_special or _is_path_selected_or_parent(to_path, selected_paths)
		
		if from_selected and to_selected:
			filtered.append(transition_data)
	
	return filtered

func _get_node_name_from_path(path: String) -> String:
	if path.is_empty():
		return ""
	var parts = path.split("/")
	return parts[parts.size() - 1]
