# spinalcord
# https://github.com/spinalcord/animation-tree-tree-godot
# 
# This file is part of animation-tree-tree-godot.
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public.
#
# NOTE: The output generated by this addon is not affected by this license.

class_name BlueprintGenerator

var _serializer: YamlSerializer

func _init():
	_serializer = YamlSerializer.new()

# Main method that produces YAML using YamlSerializer
func format_tree_node_to_yaml(node: AnimationNode, path: String, depth: int, transitions_by_path: Dictionary, selected_paths: Array[String]) -> String:
	var data = _build_tree_structure(node, path, transitions_by_path, selected_paths)
	
	if data.is_empty():
		return ""
	
	var options = YamlSerializer.SerializeOptions.new()
	options.skip_null_values = true
	options.skip_empty_collections = true
	options.pretty_multiline = false
	return _serializer.to_text(data, options)

# Build the data structure as Dictionary/Array
func _build_tree_structure(node: AnimationNode, path: String, transitions_by_path: Dictionary, selected_paths: Array[String]) -> Dictionary:
	
	# ("" and "Root") <=> Display all Nodes <=> selected_paths.size() == 0
	# => we can clear the array <=> The algorithm will return the complete structure.
	if selected_paths.has("") or selected_paths.has("Root"):
		selected_paths.clear()
	
	var is_selected = selected_paths.is_empty() or _is_path_selected_or_parent(path, selected_paths)
	var has_selected_children = selected_paths.is_empty() or _has_selected_children(path, selected_paths)
	
	if not is_selected and not has_selected_children:
		return {}
	
	var node_data = {}
	
	# Root node (depth 0 / empty path)
	if path.is_empty():
		node_data["name"] = "Root"
		node_data["type"] = node.get_class()
	else:
		var node_name = _get_node_name_from_path(path)
		node_data["name"] = node_name
		node_data["type"] = node.get_class()
		
		# Add animation name if this is an AnimationNodeAnimation
		if node is AnimationNodeAnimation:
			var animation_name = node.animation
			if not animation_name.is_empty():
				node_data["animation"] = animation_name
		
		#node_data["path"] = path # keep this for later ideas
	
	# Build children array
	var children_array = _build_children_array(node, path, transitions_by_path, selected_paths)
	
	if not children_array.is_empty():
		node_data["children"] = children_array
	
	# Add transitions if applicable
	if (is_selected or has_selected_children) and transitions_by_path.has(path):
		var transitions = transitions_by_path[path] as Array
		var filtered_transitions = _filter_transitions_by_selection(transitions, path, selected_paths) if not selected_paths.is_empty() else transitions
		
		if not filtered_transitions.is_empty():
			var transitions_array = _build_transitions_array(filtered_transitions)
			if not transitions_array.is_empty():
				node_data["transitions"] = transitions_array
	
	# Add connections if this is a BlendTree
	if node is AnimationNodeBlendTree:
		var connections_array = _get_blend_tree_connections(node as AnimationNodeBlendTree)
		if not connections_array.is_empty():
			node_data["connections"] = connections_array
	
	# Wrap root in Blueprint
	if path.is_empty():
		return {"Blueprint": node_data}
	
	return node_data

func _build_children_array(node: AnimationNode, path: String, transitions_by_path: Dictionary, selected_paths: Array[String]) -> Array:
	var children: Array = []
	
	if node is AnimationNodeStateMachine:
		var state_machine = node as AnimationNodeStateMachine
		var state_names = NodeUtils.get_container_children(state_machine)
		
		for state_name in state_names:
			var child_path = PathUtils.build_child_path(path, state_name)
			var state_node = state_machine.get("states/%s/node" % state_name) as AnimationNode
			if state_node:
				var child_data = _build_tree_structure(state_node, child_path, transitions_by_path, selected_paths)
				if not child_data.is_empty():
					children.append(child_data)
	
	elif node is AnimationNodeBlendTree:
		var blend_tree = node as AnimationNodeBlendTree
		var node_names = NodeUtils.get_container_children(blend_tree)
		
		for node_name in node_names:
			if node_name == "output":
				continue
			var child_path = PathUtils.build_child_path(path, node_name)
			var blend_node = NodeUtils.get_blend_tree_node(blend_tree, node_name)
			if blend_node:
				var child_data = _build_tree_structure(blend_node, child_path, transitions_by_path, selected_paths)
				if not child_data.is_empty():
					children.append(child_data)
	
	elif node is AnimationNodeBlendSpace1D:
		var blend_space = node as AnimationNodeBlendSpace1D
		var blend_point_count = blend_space.get_blend_point_count()
		
		for i in range(blend_point_count):
			var point_node = blend_space.get_blend_point_node(i)
			var point_position = blend_space.get_blend_point_position(i)
			var child_path = PathUtils.build_child_path(path, str(i))
			
			if point_node:
				var child_data = _build_tree_structure(point_node, child_path, transitions_by_path, selected_paths)
				if not child_data.is_empty():
					# Add blend position to child data
					child_data["blend_position"] = point_position
					children.append(child_data)
	
	elif node is AnimationNodeBlendSpace2D:
		var blend_space = node as AnimationNodeBlendSpace2D
		var blend_point_count = blend_space.get_blend_point_count()
		
		for i in range(blend_point_count):
			var point_node = blend_space.get_blend_point_node(i)
			var point_position = blend_space.get_blend_point_position(i)
			var child_path = PathUtils.build_child_path(path, "%d" % i)
			
			if point_node:
				var child_data = _build_tree_structure(point_node, child_path, transitions_by_path, selected_paths)
				if not child_data.is_empty():
					# Add blend position as x,y to child data
					child_data["blend_position"] = {"x": point_position.x, "y": point_position.y}
					children.append(child_data)
	
	return children

func _build_transitions_array(transitions: Array) -> Array:
	var transitions_array: Array = []
	
	for transition_data in transitions:
		if transition_data is Dictionary:
			var trans_dict = {}
			
			trans_dict["from"] = transition_data.get("from", "")
			trans_dict["to"] = transition_data.get("to", "")
			
			var switch_mode = transition_data.get("switch_mode", 0)
			trans_dict["switch_mode"] = get_switch_mode_text(switch_mode)
			
			# Add optional properties
			var condition = transition_data.get("advance_condition", "")
			if not condition.is_empty():
				trans_dict["condition"] = condition
			
			var expression = transition_data.get("advance_expression", "")
			if not expression.is_empty():
				trans_dict["expression"] = expression.strip_edges()
			
			var xfade_time = transition_data.get("xfade_time", 0.0)
			if xfade_time > 0.0:
				trans_dict["fade_time"] = xfade_time
			
			var priority = transition_data.get("priority", 1)
			if priority != 1:
				trans_dict["priority"] = priority
			
			var advance_mode = transition_data.get("advance_mode", 1)
			if advance_mode != 2:
				trans_dict["auto_advance"] = advance_mode == 2
			
			var reset = transition_data.get("reset", false)
			if not reset:
				trans_dict["reset"] = false
			
			transitions_array.append(trans_dict)
	
	return transitions_array

func get_switch_mode_text(switch_mode: int) -> String:
	match switch_mode:
		0: return "immediate"
		1: return "sync"
		2: return "at_end"
		_: return "unknown"

# Check if a path is directly selected or if any parent path is selected
func _is_path_selected_or_parent(path: String, selected_paths: Array[String]) -> bool:
	if path.is_empty():
		return false
	
	if path in selected_paths:
		return true
	
	for selected_path in selected_paths:
		if path.begins_with(selected_path + "/") or path == selected_path:
			return true
	
	return false

# Check if this path has any selected children
func _has_selected_children(path: String, selected_paths: Array[String]) -> bool:
	if path.is_empty():
		return not selected_paths.is_empty()
	
	for selected_path in selected_paths:
		if selected_path.begins_with(path + "/"):
			return true
	return false

# Filter transitions to only include those between selected nodes
func _filter_transitions_by_selection(transitions: Array, current_path: String, selected_paths: Array[String]) -> Array[Dictionary]:
	var filtered: Array[Dictionary] = []
	
	for transition_data in transitions:
		if not transition_data is Dictionary:
			continue
		
		var from = transition_data.get("from", "")
		var to = transition_data.get("to", "")
		
		var is_from_special = from == "Start" or from == "End"
		var is_to_special = to == "Start" or to == "End"
		
		var from_path = current_path + "/" + from if not current_path.is_empty() else from
		var to_path = current_path + "/" + to if not current_path.is_empty() else to
		
		var from_selected = is_from_special or _is_path_selected_or_parent(from_path, selected_paths)
		var to_selected = is_to_special or _is_path_selected_or_parent(to_path, selected_paths)
		
		if from_selected and to_selected:
			filtered.append(transition_data)
	
	return filtered

func _get_node_name_from_path(path: String) -> String:
	if path.is_empty():
		return ""
	var parts = path.split("/")
	return parts[parts.size() - 1]

# Extract connections from a BlendTree node
func _get_blend_tree_connections(blend_tree: AnimationNodeBlendTree) -> Array[Dictionary]:
	var connections: Array[Dictionary] = []
	
	# BlendTree stores connections in format: [to_node, to_input_port, from_node, ...]
	var node_connections = blend_tree.get("node_connections")
	
	if node_connections is Array:
		var i = 0
		while i + 2 < node_connections.size():
			var to_node = node_connections[i]
			var to_input_idx = node_connections[i + 1]
			var from_node = node_connections[i + 2]
			
			# Get input name instead of index if possible
			var to_input_name = str(to_input_idx)
			
			if to_node == "output":
				to_input_name = "in"
			else:
				var target_node = NodeUtils.get_blend_tree_node(blend_tree, to_node)
				if target_node and target_node.has_method("get_input_name"):
					to_input_name = target_node.get_input_name(to_input_idx)
			
			connections.append({
				"from": str(from_node),
				"to": str(to_node),
				"to_input": to_input_name
			})
			
			i += 3
	
	return connections
