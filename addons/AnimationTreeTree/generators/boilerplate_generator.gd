# spinalcord
# https://github.com/spinalcord/animation-tree-tree-godot
# 
# This file is part of animation-tree-tree-godot.
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public.
#
# NOTE: The output generated by this addon is not affected by this license.

class_name BoilerplateGenerator

var _boilerplate_container: DependencyContainer
var _anima_tree: AnimationTree
var _is_root_motion_track_assigned: bool = false

func _init(boilerplate_container: DependencyContainer = null) -> void:
	_boilerplate_container = boilerplate_container
	
	if boilerplate_container != null:
		_anima_tree = boilerplate_container.grab("CurrentAnimationTree")
		_is_root_motion_track_assigned = !_anima_tree.root_motion_track.is_empty()
		
	if _is_root_motion_track_assigned:
		print(_anima_tree.root_motion_track)
	
# Collect all blend spaces (1D and 2D)
func collect_blend_spaces(node: AnimationNode, path: String) -> Array[Dictionary]:
	var blend_spaces: Array[Dictionary] = []
	
	if node is AnimationNodeBlendSpace1D or node is AnimationNodeBlendSpace2D:
		var blend_space_info = {
			"path": path,
			"variable_name": _path_to_variable_name(path),
			"type": "1D" if node is AnimationNodeBlendSpace1D else "2D",
			"node": node
		}
		blend_spaces.append(blend_space_info)
	
	if node is AnimationNodeStateMachine:
		var state_names = NodeUtils.get_container_children(node)
		for state_name in state_names:
			var child_path = PathUtils.build_child_path(path, state_name)
			var state_node = node.get("states/%s/node" % state_name) as AnimationNode
			if state_node:
				var child_blend_spaces = collect_blend_spaces(state_node, child_path)
				blend_spaces.append_array(child_blend_spaces)
	
	elif node is AnimationNodeBlendTree:
		var node_names = NodeUtils.get_container_children(node)
		for node_name in node_names:
			if node_name == "output":
				continue
			var child_path = PathUtils.build_child_path(path, node_name)
			var blend_node = NodeUtils.get_blend_tree_node(node, node_name)
			if blend_node:
				var child_blend_spaces = collect_blend_spaces(blend_node, child_path)
				blend_spaces.append_array(child_blend_spaces)
	
	return blend_spaces

# Collect only selected blend spaces
func collect_selected_blend_spaces(node: AnimationNode, path: String, selected_paths: Array[String]) -> Array[Dictionary]:
	var blend_spaces: Array[Dictionary] = []
	
	var is_selected = _is_path_selected_or_parent(path, selected_paths)
	
	if (node is AnimationNodeBlendSpace1D or node is AnimationNodeBlendSpace2D) and is_selected:
		var blend_space_info = {
			"path": path,
			"variable_name": _path_to_variable_name(path),
			"type": "1D" if node is AnimationNodeBlendSpace1D else "2D",
			"node": node
		}
		blend_spaces.append(blend_space_info)
	
	if node is AnimationNodeStateMachine:
		var state_names = NodeUtils.get_container_children(node)
		for state_name in state_names:
			var child_path = PathUtils.build_child_path(path, state_name)
			var state_node = node.get("states/%s/node" % state_name) as AnimationNode
			if state_node:
				var child_blend_spaces = collect_selected_blend_spaces(state_node, child_path, selected_paths)
				blend_spaces.append_array(child_blend_spaces)
	
	elif node is AnimationNodeBlendTree:
		var node_names = NodeUtils.get_container_children(node)
		for node_name in node_names:
			if node_name == "output":
				continue
			var child_path = PathUtils.build_child_path(path, node_name)
			var blend_node = NodeUtils.get_blend_tree_node(node, node_name)
			if blend_node:
				var child_blend_spaces = collect_selected_blend_spaces(blend_node, child_path, selected_paths)
				blend_spaces.append_array(child_blend_spaces)
	
	return blend_spaces

# Original method for collecting all state machines
func collect_state_machines(node: AnimationNode, path: String) -> Array[Dictionary]:
	var state_machines: Array[Dictionary] = []
	
	if node is AnimationNodeStateMachine:
		var state_machine_info = {
			"path": path,
			"variable_name": _path_to_variable_name(path),
			"states": _get_state_machine_states(node as AnimationNodeStateMachine),
			"node": node,
			"parent_path": _get_parent_path(path)
		}
		state_machines.append(state_machine_info)
		
		# Recursively check child states
		var state_names = NodeUtils.get_container_children(node)
		for state_name in state_names:
			var child_path = PathUtils.build_child_path(path, state_name)
			var state_node = node.get("states/%s/node" % state_name) as AnimationNode
			if state_node:
				var child_state_machines = collect_state_machines(state_node, child_path)
				state_machines.append_array(child_state_machines)
	
	elif node is AnimationNodeBlendTree:
		var node_names = NodeUtils.get_container_children(node)
		for node_name in node_names:
			if node_name == "output":
				continue
			var child_path = PathUtils.build_child_path(path, node_name)
			var blend_node = NodeUtils.get_blend_tree_node(node, node_name)
			if blend_node:
				var child_state_machines = collect_state_machines(blend_node, child_path)
				state_machines.append_array(child_state_machines)
	
	return state_machines

# New method for collecting only selected state machines
func collect_selected_state_machines(node: AnimationNode, path: String, selected_paths: Array[String]) -> Array[Dictionary]:
	var state_machines: Array[Dictionary] = []
	
	# Check if current path or any parent path is in selection
	var is_selected = _is_path_selected_or_parent(path, selected_paths)
	var has_selected_children = _has_selected_children(path, selected_paths)
	
	if node is AnimationNodeStateMachine:
		# Include this state machine if it's selected or has selected children
		if is_selected or has_selected_children:
			var state_machine_info = {
				"path": path,
				"variable_name": _path_to_variable_name(path),
				"states": _get_filtered_states(node as AnimationNodeStateMachine, path, selected_paths),
				"node": node,
				"parent_path": _get_parent_path(path)
			}
			
			# Only add if it has states (after filtering)
			if not state_machine_info.states.is_empty():
				state_machines.append(state_machine_info)
		
		# Always recurse into child states to find selected ones
		var state_names = NodeUtils.get_container_children(node)
		for state_name in state_names:
			var child_path = PathUtils.build_child_path(path, state_name)
			var state_node = node.get("states/%s/node" % state_name) as AnimationNode
			if state_node:
				var child_state_machines = collect_selected_state_machines(state_node, child_path, selected_paths)
				state_machines.append_array(child_state_machines)
	
	elif node is AnimationNodeBlendTree:
		# Always recurse into blend tree nodes to find selected state machines
		var node_names = NodeUtils.get_container_children(node)
		for node_name in node_names:
			if node_name == "output":
				continue
			var child_path = PathUtils.build_child_path(path, node_name)
			var blend_node = NodeUtils.get_blend_tree_node(node, node_name)
			if blend_node:
				var child_state_machines = collect_selected_state_machines(blend_node, child_path, selected_paths)
				state_machines.append_array(child_state_machines)
	
	return state_machines

# Check if a path is directly selected or if any parent path is selected
func _is_path_selected_or_parent(path: String, selected_paths: Array[String]) -> bool:
	if path in selected_paths:
		return true
	
	# Check if any parent path is selected
	for selected_path in selected_paths:
		if path.begins_with(selected_path + "/") or path == selected_path:
			return true
	
	return false

# Check if this path has any selected children
func _has_selected_children(path: String, selected_paths: Array[String]) -> bool:
	for selected_path in selected_paths:
		if selected_path.begins_with(path + "/"):
			return true
	
	return false

# Get only the states that are selected or have selected children
func _get_filtered_states(state_machine: AnimationNodeStateMachine, current_path: String, selected_paths: Array[String]) -> Array[String]:
	var filtered_states: Array[String] = []
	var all_states = _get_state_machine_states(state_machine)
	
	for state_name in all_states:
		var state_path = PathUtils.build_child_path(current_path, state_name)
		
		# Include state if it's selected or has selected children
		if _is_path_selected_or_parent(state_path, selected_paths) or _has_selected_children(state_path, selected_paths):
			filtered_states.append(state_name as String)
	
	return filtered_states

# Generate complete boilerplate code with match statements in _physics_process
func generate_complete_boilerplate(state_machines: Array[Dictionary], blend_spaces: Array[Dictionary] = []) -> String:
	var code = ""
	
	# Export variables
	code += "extends Node # Change Node to another Type if needed\n"
	code += "@export var anim_player: AnimationPlayer\n"
	code += "@export var anim_tree: AnimationTree\n\n"
	
	# Gravity constant
	code += "# Depends on the node type choose the appropriate gravity constant\n"
	code += "#@onready var GRAVITY: float = ProjectSettings.get_setting(\"physics/2d/default_gravity\")\n"
	code += "#@onready var GRAVITY: float = ProjectSettings.get_setting(\"physics/3d/default_gravity\")\n\n"
	
	# OnReady variables for state machines
	if not state_machines.is_empty():
		code += "# Generated AnimationNodeStateMachinePlayback variables\n"
		for sm_info in state_machines:
			var path = sm_info.path
			var var_name = sm_info.variable_name
			
			var param_path = "parameters"
			if not path.is_empty():
				param_path += "/" + path
			param_path += "/playback"
			
			code += "@onready var %s: AnimationNodeStateMachinePlayback = anim_tree.get(\"%s\")\n" % [var_name, param_path]
		code += "\n"
	
	# OnReady variables for blend spaces
	if not blend_spaces.is_empty():
		code += "# Generated BlendSpace variables\n"
		for bs_info in blend_spaces:
			var path = bs_info.path
			var var_name = bs_info.variable_name
			var bs_type = bs_info.type
			
			var param_path = "parameters"
			if not path.is_empty():
				param_path += "/" + path
			param_path += "/blend_position"
			
			var type_hint = "Vector2" if bs_type == "2D" else "float"
			var example_value = "Vector2(x_1, y_1)" if bs_type == "2D" else "value"
			code += "# Example to set the blend position: anim_tree.set(\"%s\", %s)\n" % [param_path, example_value]
			code += "@onready var %s: %s = anim_tree.get(\"%s\") as %s\n" % [var_name, type_hint, param_path, type_hint]
		code += "\n"
	
	# _ready function
	code += "func _ready() -> void:\n"
	code += "\tassert(anim_tree != null, \"AnimationTree was not assigned\")\n"
	code += "\tassert(anim_player != null, \"AnimationPlayer was not assigned\")\n"
	code += "\tanim_tree.animation_finished.connect(_on_animation_finished)\n\n"
	
	# _on_animation_finished function
	code += "func _on_animation_finished(anim_name: String) -> void:\n"
	code += "\tpass\n\n"
	
	# _physics_process function with match statements
	code += "func _physics_process(delta: float) -> void:\n"
	code += "\t#region Setup Gravity\n"
	code += "\tif not is_on_floor():\n"
	code += "\t\tvelocity.y -= GRAVITY * delta\n"
	code += "\telse:\n"
	code += "\t\tvelocity.y = 0.0\n"
	code += "\t#endregion Setup Gravity\n"
	code += "\t\n"
	
	if _is_root_motion_track_assigned:
		code += "\t#region Setup Root Motion\n"
		code += "\t# Get root motion from AnimationTree\n"
		code += "\tvar root_motion_position: Vector3 = anim_tree.get_root_motion_position()\n"
		code += "\tvar root_motion_rotation: Quaternion = anim_tree.get_root_motion_rotation()\n"
		code += "\t\n"
		code += "\t# Apply root motion rotation (from animations)\n"
		code += "\tquaternion = quaternion * root_motion_rotation\n"
		code += "\t\n"
		code += "\t# Calculate velocity from root motion using rotation accumulator\n"
		code += "\tvar root_rotation_accumulator: Quaternion = anim_tree.get_root_motion_rotation_accumulator()\n"
		code += "\tvar horizontal_velocity: Vector3 = (root_rotation_accumulator.inverse() * quaternion) * root_motion_position / delta\n"
		code += "\t\n"
		code += "\tvelocity.x = horizontal_velocity.x\n"
		code += "\tvelocity.z = horizontal_velocity.z\n"
		code += "\t#endregion Setup Root Motion\n"
		code += "\t\n"
	
	if state_machines.is_empty():
		code += "\tpass\n"
	else:
		var root_state_machines = _find_root_state_machines(state_machines)
		for root_sm in root_state_machines:
			code += _generate_nested_match_statements(root_sm, state_machines, 1)
		code += "\t\n"
		code += "\t# move_and_slide() # Decomment if Node is a CharacterBody-Node-Type\n"
		
	
	return code

func generate_onready_variables(state_machines: Array[Dictionary], blend_spaces: Array[Dictionary] = []) -> String:
	var code = ""
	
	# State machines
	if not state_machines.is_empty():
		code += "# Generated AnimationNodeStateMachinePlayback variables\n"
		for sm_info in state_machines:
			var path = sm_info.path
			var var_name = sm_info.variable_name
			
			var param_path = "parameters"
			if not path.is_empty():
				param_path += "/" + path
			param_path += "/playback"
			
			code += "@onready var %s: AnimationNodeStateMachinePlayback = anim_tree.get(\"%s\")\n" % [var_name, param_path]
		code += "\n"
	
	# Blend spaces
	if not blend_spaces.is_empty():
		code += "# Generated BlendSpace variables\n"
		for bs_info in blend_spaces:
			var path = bs_info.path
			var var_name = bs_info.variable_name
			var bs_type = bs_info.type
			
			var param_path = "parameters"
			if not path.is_empty():
				param_path += "/" + path
			param_path += "/blend_position"
			
			var type_hint = "Vector2" if bs_type == "2D" else "float"
			var example_value = "Vector2(x_1, y_1)" if bs_type == "2D" else "value"
			code += "# Example to set the blend position: anim_tree.set(\"%s\", %s)\n" % [param_path, example_value]
			code += "@onready var %s: %s = anim_tree.get(\"%s\") as %s\n" % [var_name, type_hint, param_path, type_hint]
		code += "\n"
	
	return code

func generate_complete_match_statements(state_machines: Array[Dictionary]) -> String:
	var code = "# Generated nested match statements\n"
	code += "# Add this to your _physics_process or appropriate function\n\n"
	
	if state_machines.is_empty():
		return code + "# No state machines found\n"
	
	var root_state_machines = _find_root_state_machines(state_machines)
	
	for root_sm in root_state_machines:
		code += _generate_nested_match_statements(root_sm, state_machines, 0)
		code += "\n"
	
	return code

static func _get_state_machine_states(state_machine: AnimationNodeStateMachine) -> Array[String]:
	var states: Array[String] = []
	var state_names = NodeUtils.get_container_children(state_machine)
	for state_name in state_names:
		states.append(state_name as String)
	return states

func _path_to_variable_name(path: String) -> String:
	if path.is_empty():
		return "root_state_machine"
	
	var var_name = path.replace("/", "_").to_snake_case()
	if var_name[0].is_valid_int():
		var_name = "sm_" + var_name
	
	return var_name

func _get_parent_path(path: String) -> String:
	if path.is_empty():
		return ""
	var parts = path.split("/")
	if parts.size() <= 1:
		return ""
	parts.remove_at(parts.size() - 1)
	return "/".join(parts)

func _find_root_state_machines(state_machines: Array[Dictionary]) -> Array[Dictionary]:
	var root_state_machines: Array[Dictionary] = []
	for sm_info in state_machines:
		if sm_info.path.is_empty() or sm_info.path.find("/") == -1:
			root_state_machines.append(sm_info)
	
	if root_state_machines.is_empty() and state_machines.size() > 0:
		root_state_machines.append(state_machines[0])
	
	return root_state_machines

func _generate_nested_match_statements(sm_info: Dictionary, all_state_machines: Array[Dictionary], indent_level: int) -> String:
	var indent = "\t".repeat(indent_level)
	var var_name = sm_info.variable_name
	var states = sm_info.states
	
	var code = "%smatch %s.get_current_node():\n" % [indent, var_name]
	
	for state in states:
		code += "%s\t\"%s\":\n" % [indent, state]
		
		# Find direct child state machine for this state
		var nested_state_machine = _find_direct_nested_state_machine(sm_info.path, state, all_state_machines)
		
		if nested_state_machine:
			code += "%s\t\t# Nested state machine: %s\n" % [indent, nested_state_machine.variable_name]
			var nested_code = _generate_nested_match_statements(nested_state_machine, all_state_machines, indent_level + 2)
			code += nested_code
		else:
			code += "%s\t\t# TODO: Add logic for %s state\n" % [indent, state]
			code += "%s\t\tpass\n" % [indent]
	
	code += "%s\t_: # Default case\n" % [indent]
	code += "%s\t\t# Handle unknown state\n" % [indent]
	code += "%s\t\tpass\n" % [indent]
	
	return code

# Find only the direct nested state machine for a specific state
func _find_direct_nested_state_machine(parent_path: String, state_name: String, all_state_machines: Array[Dictionary]) -> Dictionary:
	var target_path = PathUtils.build_child_path(parent_path, state_name)
	
	# Look for exact path match first (direct child)
	for sm_info in all_state_machines:
		if sm_info.path == target_path:
			return sm_info
	
	return {}

func _find_nested_state_machines(parent_path: String, state_name: String, all_state_machines: Array[Dictionary]) -> Array[Dictionary]:
	var nested_machines: Array[Dictionary] = []
	var target_path = PathUtils.build_child_path(parent_path, state_name)
	
	for sm_info in all_state_machines:
		if sm_info.path == target_path:
			nested_machines.append(sm_info)
		elif sm_info.path.begins_with(target_path + "/"):
			var relative_path = sm_info.path.substr(target_path.length() + 1)
			if relative_path.find("/") == -1:
				nested_machines.append(sm_info)
	
	return nested_machines
