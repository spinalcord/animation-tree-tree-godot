# spinalcord
# https://github.com/spinalcord/animation-tree-tree-godot
# 
# This file is part of animation-tree-tree-godot.
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public.
#
# NOTE: The output generated by this addon is not affected by this license.

## AIManager handles AI-related operations and expert interactions
class_name AIManager
var feedback: FeedbackDialog

const FSM_EXPERT = "State Machine Generator Expert"
const SCRIPT_EXPERT = "Script Generator Expert"

var _animation_tree: AnimationTree
var _target_path: String
var _selected_paths: Array[String] # returns every selection in TreeView as a path
var _selected_parent_paths: Array[String] # returns every selection (that is a parent) in TreeView as a path
var _all_parent_paths: Array[String] # No matter what: returns all nodes, which can be a parent
var _current_animations:  Array[String]
var _current_expression_base_node_script: String
var _export_manager: ExportManager
var _experts: Dictionary = {}

func _init(feedback_dialog: FeedbackDialog) -> void:
	self.feedback = feedback_dialog
	

func _register_experts(container: DependencyContainer) -> void:
	var fsm_expert = FSMExpert.new(self, container)
	var script_expert = ScriptGeneratorExpert.new(self , container)
	
	_experts[fsm_expert.name] = fsm_expert
	_experts[script_expert.name] = script_expert

func execute_ai_action(container: DependencyContainer, backup_callable: Callable) -> String:
	_animation_tree = container.grab("CurrentAnimationTree")
	_target_path = container.grab("TargetPath")
	_current_animations = container.grab("AvaibleAnimations")
	_selected_parent_paths = container.grab("SelectedNodeParentPaths")
	_selected_paths = container.grab("SelectedNodePaths")
	_current_expression_base_node_script = container.grab("CurrentExpressionBaseNodeScript")
	_all_parent_paths = container.grab("AllNodeParentPaths")
	_export_manager = ExportManager.new()
	
	_register_experts(container)
	
	if _animation_tree == null:
		await feedback.show_info("No AnimationTree selected", "No AnimationTree selected")
		return ""
	
	var selected_blueprint: String = _export_manager.export_tree_as_yaml(_animation_tree, _selected_paths)
	var prompt_dialog = _create_prompt_dialog()
	var apply = await prompt_dialog.show()
	
	if not apply:
		TreeDebug.msg("canceled")
		return ""
	
	TreeDebug.msg("applayed successfully!")
	
	var con_ai: ConAI = ConAI.new()
	var avaible_types: Array[String] = prompt_dialog.get_value("node_type").keys()
	var expert_type = prompt_dialog.get_value("expert")
	var user_input: String = prompt_dialog.get_value("prompt")
	var include_excerpt: bool = prompt_dialog.get_value("include_excerpt")
	var boilerplat: String = _export_manager.export_tree_as_boilerplate(_animation_tree, _selected_paths)
	var script_content: String = _current_expression_base_node_script
	
	if user_input.is_empty():
		return ""
	
	if _current_expression_base_node_script.strip_edges().is_empty() or include_excerpt == false:
		script_content = ""
	
	var expert: Expert = _experts.get(expert_type)
	if expert == null:
		TreeDebug.msg("Expert not found: " + expert_type)
		return ""
	
	var system_prompt_path = AnimationTreeTree.ai_system_prompt_path + expert.get_system_prompt()
	var system_prompt = _build_system_prompt(
		system_prompt_path,
		_target_path,
		_current_animations,
		script_content,
		avaible_types,
		boilerplat,
		selected_blueprint,
		_all_parent_paths
	)
	
	
	if AnimationTreeTree.plugin_config.get_value("settings", "debug_system_prompt", false):
		feedback.show_text(
			"Debug: Rendered system prompt with all variables resolved and conditions evaluated",
			"System Prompt Preview", 
			system_prompt, 
			true
		)
		return ""
	
	backup_callable.call()
	await expert.process(con_ai, system_prompt, user_input)
	return ""
	
func _create_prompt_dialog() -> ConfigDialog:
	var prompt_fields: Array[ConfigField] = []

	
	prompt_fields.append(ConfigField.new(
		"prompt", 
		"Prompt", 
		"Enter detailed description what you want from the Expert-AI", 
		"General", 
		"string_multi", 
		""
	))
	
	for expert in _experts.values():
		var expert_fields = expert.get_config_fields()
		for field in expert_fields:
			prompt_fields.append(field)
	
	var expert_names: Array[String] = []
	for expert_name in _experts.keys():
		expert_names.append(expert_name)
	
	prompt_fields.append(ConfigField.new(
		"expert", 
		"Which expert you need?", 
		"Based on the expert you have chosen, you get an appropriate result.", 
		"General", 
		"combo_box", 
		expert_names
	))
	
	var warnings: String = ""
	
	if _current_animations.size() == 0:
		warnings += "- Your AnimationPlayer has no animations!\n"

	if _current_expression_base_node_script.strip_edges().is_empty():
		warnings += "- Your ExpressionBaseNode Script has no boolean types, therefore State Machine Expert will likely assume expressions."
	
	prompt_fields.append(ConfigField.new(
		"target_info", 
		"Working on AnimationTree Node: '%s'. " % [_target_path if !_target_path.is_empty() else "Root"], 
		"Your selection", 
		"General", 
		"callout", 
        "none"
	))
	
	if warnings.is_empty() == false:
		prompt_fields.append(ConfigField.new(
			"prompt_warnings", 
			warnings, 
			"Beaware you have some warnings", 
			"General", 
			"callout", 
	        "warning"
		))
	
	if AnimationTreeTree.plugin_config.get_value("settings", "debug_system_prompt", false) == true:
		prompt_fields.append(ConfigField.new(
			"debug_system_prompt_warning", 
			"You have \"Debug System Prompt\" enabled in the settings, therefor only the system prompt will be shown. No AI Request will be performed.", 
			"", 
			"General", 
			"callout", 
	        "error"
		))
	
	return ConfigDialog.new("prompt.cfg", prompt_fields)

func _build_system_prompt(
	system_prompt_path: String,
	target_path: String,
	avaible_animations:  Array[String],
	script_content: String,
	avaible_types: Array[String],
	boilerplate: String,
	blueprint: String,
	avaible_parents: Array[String]
) -> String:
	var template = _read_file(system_prompt_path)
	var _stache: GDStache = GDStache.new()
	var data = {
		"script_excerpt": script_content,
		"has_excerpt": false if script_content.is_empty() else true,
		"target_path": target_path,
		"has_animations": true if avaible_animations.size() > 0 else false,
		"avaible_animations": avaible_animations,
		"avaible_parents": avaible_parents,
		"has_parents": true if avaible_parents.size() > 0 else false,
		"avaible_types": avaible_types,
		"boilerplate": boilerplate,
		"blueprint": blueprint,
		"input_map": InputMap.get_actions()
	}
	
	return _stache.render(template, data)

func _read_file(file_path: String) -> String:
	var script_path = ""
	var stack = get_stack()
	if stack.size() > 0:
		script_path = stack[0].source
	
	var file = FileAccess.open( file_path, FileAccess.READ)
	
	if file == null:
		print("Error reading file: ", FileAccess.get_open_error())
		return ""
	
	var content = file.get_as_text()
	file.close()
	
	return content

func extract_block_from_markdown(text: String, block_name: String) -> Array:
	var regex = RegEx.new()
	regex.compile("```" + block_name + "\\s*\\n([\\s\\S]*?)\\n```")
	
	var blocks = []
	var results = regex.search_all(text)
	
	for result in results:
		blocks.append(result.get_string(1))
	
	return blocks
