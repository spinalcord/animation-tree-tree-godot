# spinalcord
# https://github.com/spinalcord/animation-tree-tree-godot
# 
# This file is part of animation-tree-tree-godot.
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public.
#
# NOTE: The output generated by this addon is not affected by this license.

# AIManager handles AI-related operations and expert interactions
class_name AIManager
var feedback: FeedbackDialog

const FSM_EXPERT = "State Machine Generator Expert"
const SCRIPT_EXPERT = "Script Generator Expert"

var _animation_tree: AnimationTree
var _target_path: String
var _selected_paths: Array[String] # returns every selection in TreeView as a path
var _selected_parent_paths: Array[String] # returns every selection (that is a parent) in TreeView as a path
var _all_parent_paths: Array[String] # No matter what: returns all nodes, which can be a parent
var _current_animations:  Array[String]
var _current_expression_base_node_script: String
var _export_manager: ExportManager
var _experts: Dictionary = {}

func _init(feedback_dialog: FeedbackDialog) -> void:
	self.feedback = feedback_dialog
	

func _register_experts(container: DependencyContainer) -> void:
	var fsm_expert = FSMExpert.new(self, container)
	var script_expert = ScriptGeneratorExpert.new(self , container)
	
	_experts[fsm_expert.name] = fsm_expert
	_experts[script_expert.name] = script_expert

func execute_ai_action(container: DependencyContainer) -> String:
	_animation_tree = container.grab("CurrentAnimationTree")
	_target_path = container.grab("TargetPath")
	_current_animations = container.grab("AvaibleAnimations")
	_selected_parent_paths = container.grab("SelectedNodeParentPaths")
	_selected_paths = container.grab("SelectedNodePaths")
	_current_expression_base_node_script = container.grab("CurrentExpressionBaseNodeScript")
	_all_parent_paths = container.grab("AllNodeParentPaths")
	_export_manager = ExportManager.new()
	
	_register_experts(container)
	
	if _animation_tree == null:
		await feedback.show_info("No AnimationTree selected", "No AnimationTree selected")
		return ""
	
	var selected_blueprint: String = _export_manager.export_tree_as_yaml(_animation_tree, _selected_paths)
	var prompt_dialog = _create_prompt_dialog()
	var apply = await prompt_dialog.show()
	
	if not apply:
		TreeDebug.msg("canceled")
		return ""
	
	TreeDebug.msg("applayed successfully!")
	
	var con_ai: ConAI = ConAI.new()
	var avaible_types: Array[String] = prompt_dialog.get_value("node_type").keys()
	var expert_type = prompt_dialog.get_value("expert")
	var user_input: String = prompt_dialog.get_value("prompt")
	var include_excerpt: bool = prompt_dialog.get_value("include_excerpt")
	var boilerplat: String = _export_manager.export_tree_as_boilerplate(_animation_tree, _selected_paths)
	var script_content: String = _current_expression_base_node_script
	
	if user_input.is_empty():
		return ""
	
	if _current_expression_base_node_script.strip_edges().is_empty() or include_excerpt == false:
		script_content = ""
	
	var expert: Expert = _experts.get(expert_type)
	if expert == null:
		TreeDebug.msg("Expert not found: " + expert_type)
		return ""
	
	var system_prompt_path = AnimationTreeTree.ai_system_prompt_path + expert.get_system_prompt()
	var system_prompt = _build_system_prompt(
		system_prompt_path,
		_target_path,
		_current_animations,
		script_content,
		avaible_types,
		boilerplat,
		selected_blueprint,
		_all_parent_paths
	)
	#print(system_prompt)
	#return ""
	await expert.process(con_ai, system_prompt, user_input)
	return ""
	
func _create_prompt_dialog() -> ConfigDialog:
	var prompt_fields: Array[ConfigField] = []

	
	prompt_fields.append(ConfigField.new(
		"prompt", 
		"Prompt", 
		"Enter detailed description what you want from the Expert-AI", 
		"General", 
		"string_multi", 
		""
	))
	
	for expert in _experts.values():
		var expert_fields = expert.get_config_fields()
		for field in expert_fields:
			prompt_fields.append(field)
	
	var expert_names: Array[String] = []
	for expert_name in _experts.keys():
		expert_names.append(expert_name)
	
	prompt_fields.append(ConfigField.new(
		"expert", 
		"Which expert you need?", 
		"Based on the expert you have chosen, you get an appropriate result.", 
		"General", 
		"combo_box", 
		expert_names
	))
	
	var warnings: String = ""
	
	if _current_animations.size() == 0:
		warnings += "- Your AnimationPlayer has no animations!\n"

	if _current_expression_base_node_script.strip_edges().is_empty():
		warnings += "- Your ExpressionBaseNode Script has no boolean types, therefore State Machine Expert will likely assume expressions."
	
	prompt_fields.append(ConfigField.new(
		"target_info", 
		"Working on AnimationTree Node: '%s'. " % [_target_path if !_target_path.is_empty() else "Root"], 
		"Your selection", 
		"General", 
		"callout", 
        "none"
	))
	
	if warnings.is_empty() == false:
		prompt_fields.append(ConfigField.new(
			"prompt_warnings", 
			warnings, 
			"Beaware you have some warnings", 
			"General", 
			"callout", 
	        "warning"
		))
	
	return ConfigDialog.new("prompt.cfg", prompt_fields)

func _build_system_prompt(
	system_prompt_path: String,
	target_path: String,
	avaible_animations:  Array[String],
	script_content: String,
	avaible_types: Array[String],
	boilerplate: String,
	blueprint: String,
	avaible_parents: Array[String]
) -> String:
	var template = _read_file(system_prompt_path)
	var _stache: GDStache = GDStache.new()
	var data = {
		"script_excerpt": script_content,
		"has_excerpt": false if script_content.is_empty() else true,
		"target_path": target_path,
		"has_animations": true if avaible_animations.size() > 0 else false,
		"avaible_animations": avaible_animations,
		"avaible_parents": avaible_parents,
		"has_parents": true if avaible_parents.size() > 0 else false,
		"avaible_types": avaible_types,
		"boilerplate": boilerplate,
		"blueprint": blueprint,
		"input_map": InputMap.get_actions()
	}
	
	return _stache.render(template, data)

func _read_file(file_path: String) -> String:
	var script_path = ""
	var stack = get_stack()
	if stack.size() > 0:
		script_path = stack[0].source
	
	var file = FileAccess.open( file_path, FileAccess.READ)
	
	if file == null:
		print("Error reading file: ", FileAccess.get_open_error())
		return ""
	
	var content = file.get_as_text()
	file.close()
	
	return content

func extract_block_from_markdown(text: String, block_name: String) -> Array:
	var regex = RegEx.new()
	regex.compile("```" + block_name + "\\s*\\n([\\s\\S]*?)\\n```")
	
	var blocks = []
	var results = regex.search_all(text)
	
	for result in results:
		blocks.append(result.get_string(1))
	
	return blocks
