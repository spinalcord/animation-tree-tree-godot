# spinalcord
# https://github.com/spinalcord/animation-tree-tree-godot
# 
# This file is part of animation-tree-tree-godot.
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public.
#
# NOTE: The output generated by this addon is not affected by this license.

# AIManager handles AI-related operations and expert interactions
class_name AIManager
var feedback: FeedbackDialog

const FSM_EXPERT = "State Machine Generator Expert"
const SCRIPT_EXPERT = "Script Generator Expert"

var _animation_tree: AnimationTree
var _target_path: String
var _selected_paths: Array[String]
var _get_animations_callback: Callable
var _get_script_callback: Callable
var _refresh_callback: Callable
var _export_manager: ExportManager

func _init(feedback_dialog: FeedbackDialog) -> void:
	self.feedback = feedback_dialog

func execute_ai_action(
	animation_tree: AnimationTree,
	target_path: String,
	selected_paths: Array[String],
	get_animations_callback: Callable,
	get_script_callback: Callable,
	refresh_callback: Callable,
	export_manager: ExportManager
) -> String:
	_animation_tree = animation_tree
	_target_path = target_path
	_selected_paths = selected_paths
	_get_animations_callback = get_animations_callback
	_get_script_callback = get_script_callback
	_refresh_callback = refresh_callback
	_export_manager = export_manager
	
	var selected_blueprint: String = _export_manager.export_tree_as_yaml(_animation_tree, _selected_paths)
	var prompt_dialog = _create_prompt_dialog()
	var apply = await prompt_dialog.show()
	
	if not apply:
		TreeDebug.msg("canceled")
		return ""
	
	TreeDebug.msg("applayed successfully!")
	
	var con_ai: ConAI = ConAI.new()
	var avaible_types = ",".join(prompt_dialog.get_value("node_type").keys().filter(func(key): return prompt_dialog.get_value("node_type")[key]))
	var expert_type = prompt_dialog.get_value("expert")
	var user_input: String = prompt_dialog.get_value("prompt")
	var include_excerpt: bool = prompt_dialog.get_value("include_excerpt")
	var boilerplat: String = _export_manager.generate_animation_tree_boilerplate(_animation_tree, _selected_paths)
	var script_content: String = _get_script_callback.call()
	
	if user_input.is_empty():
		return ""
	
	if _get_script_callback.call().strip_edges().is_empty() or include_excerpt == false:
		script_content = "No excerpt provided"
	
	var system_prompt = _build_system_prompt(
		expert_type,
		_target_path,
		_get_animations_callback.call(),
		script_content,
		avaible_types,
		boilerplat,
		selected_blueprint
	)
	
	if expert_type == FSM_EXPERT:
		await _process_fsm_expert(con_ai, system_prompt, user_input)
	elif expert_type == SCRIPT_EXPERT:
		await _process_script_expert(con_ai, system_prompt, user_input)
	return ""
	
func _create_prompt_dialog() -> ConfigDialog:
	var prompt_fields: Array[ConfigField] = []
	
	prompt_fields.append(ConfigField.new(
		"prompt", 
		"Prompt", 
		"Enter detailed description what you want from the Expert-AI", 
		"General", 
		"string_multi", 
		""
	))
	
	prompt_fields.append(ConfigField.new(
		"node_type", 
		"Allowed Node Types", 
		"Select which node types should the expert included/excluded", 
		"State Machine Expert", 
		"decision", 
		{
			"StateMachine": true,
			"BlendTree": true,
			"Animation": true,
			"Blend2": true,
			"Blend3": true,
			"BlendSpace1D": true,
			"BlendSpace2D": true,
			"TimeScale": true,
			"TimeSeek": true,
			"Transition": true
		}
	))
	
	prompt_fields.append(ConfigField.new(
		"include_excerpt", 
		"Include Expression Excerpt", 
		"Includes an excerpt (Only booleans) of your \"Advance Expression Base Node\" attached script assigned to your AnimationTree.", 
		"State Machine Expert", 
		"bool", 
		true
	))
	
	prompt_fields.append(ConfigField.new(
		"expert", 
		"Which expert you need?", 
		"Based on the expert you have chosen, you get an appropriate result.", 
		"General", 
		"combo_box", 
		[FSM_EXPERT, SCRIPT_EXPERT]
	))
	
	var warnings: String = ""
	
	if (_get_animations_callback.call() as String).strip_edges().is_empty():
		warnings += "- Your AnimationPlayer has no animations!\n"

	if _get_script_callback.call().strip_edges().is_empty():
		warnings += "- Your ExpressionBaseNodeScript has no boolean types, therefore some experts are going to assume expressions."
	
	if warnings.is_empty() == false:
		prompt_fields.append(ConfigField.new(
			"prompt_warnings", 
			warnings, 
			"Beaware you have some warnings", 
			"General", 
			"callout", 
	        "warning"
		))
	
	
	return ConfigDialog.new("prompt.cfg", prompt_fields)

func _build_system_prompt(
	expert_type: String,
	target_path: String,
	avaible_animations: String,
	script_content: String,
	avaible_types: String,
	boilerplate: String,
	blueprint: String
) -> String:
	var system_prompt_path = ""
	if expert_type == FSM_EXPERT:
		system_prompt_path = "ai/agents/system_prompts/fsm_expert.txt"
	elif expert_type == SCRIPT_EXPERT:
		system_prompt_path = "ai/agents/system_prompts/script_generator_expert.txt"
	
	var systemprompt = _read_file(system_prompt_path)
	
	systemprompt = systemprompt.replace("{{script_excerpt}}", script_content)
	systemprompt = systemprompt.replace("{{target_path}}", target_path)
	systemprompt = systemprompt.replace("{{avaible_animations}}", avaible_animations)
	systemprompt = systemprompt.replace("{{avaible_types}}", avaible_types)
	systemprompt = systemprompt.replace("{{boilerplate}}", boilerplate)
	systemprompt = systemprompt.replace("{{blueprint}}", blueprint)
	
	return systemprompt

func _process_fsm_expert(
	con_ai: ConAI,
	system_prompt: String,
	user_input: String
) -> void:
	var fsm_agent: Agent = Agent.new()
	fsm_agent.system_prompt = system_prompt
	
	var temp_conversation: Conversation = Conversation.new()
	var sample_tools = SampleTools.new()
	
	await con_ai.answer(fsm_agent, temp_conversation, sample_tools, user_input)
	var llm_result = temp_conversation.get_last_message("assistant")
	var all_produced_yaml: Array = _extract_block_from_markdown(llm_result, "yaml")
	
	if all_produced_yaml.size() > 0:
		var first_yaml: String = all_produced_yaml[0]
		var builder: AnimationTreeScriptBuilder = AnimationTreeScriptBuilder.new()
		builder.build_from_script(_animation_tree, first_yaml)
		_refresh_callback.call()
		EditorInterface.mark_scene_as_unsaved()

func _process_script_expert(
	con_ai: ConAI,
	system_prompt: String,
	user_input: String
) -> void:
	var script_agent: Agent = Agent.new()
	var script_expert_tools = ScriptExpertTools.new()
	
	script_agent.system_prompt = system_prompt
	
	var temp_conversation: Conversation = Conversation.new()
	await con_ai.answer(script_agent, temp_conversation, script_expert_tools, user_input)
	var llm_result = temp_conversation.get_last_message("assistant")
	
	TreeDebug.msg("LLM Result: " + str(llm_result))
	
	var all_produced_gdscripts: Array = _extract_block_from_markdown(llm_result, "gdscript")
	
	TreeDebug.msg("Extracted GDScript blocks: " + str(all_produced_gdscripts.size()))
	
	if all_produced_gdscripts.size() > 0:
		var first_gdscript: String = all_produced_gdscripts[0]
		await feedback.show_text("Script suggestion", "Script suggestion", first_gdscript, true)
	else:
		if llm_result.strip_edges().is_empty() == false:
			await feedback.show_text("Script suggestion", "Raw AI Response", llm_result, true)

func _read_file(relativ_file_path: String) -> String:
	var script_path = ""
	var stack = get_stack()
	if stack.size() > 0:
		script_path = stack[0].source
	
	var file = FileAccess.open(AnimationTreeTree.plugin_path + relativ_file_path, FileAccess.READ)
	
	if file == null:
		print("Error opening file: ", FileAccess.get_open_error())
		return ""
	
	var content = file.get_as_text()
	file.close()
	
	return content

func _extract_block_from_markdown(text: String, block_name: String) -> Array:
	var regex = RegEx.new()
	regex.compile("```" + block_name + "\\s*\\n([\\s\\S]*?)\\n```")
	
	var blocks = []
	var results = regex.search_all(text)
	
	for result in results:
		blocks.append(result.get_string(1))
	
	return blocks
