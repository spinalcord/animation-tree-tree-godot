# spinalcord
# https://github.com/spinalcord/animation-tree-tree-godot
# 
# This file is part of animation-tree-tree-godot.
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public.
#
# NOTE: The output generated by this addon is not affected by this license.

# AIManager handles AI-related operations and expert interactions
class_name AIManager
var feedback: FeedbackDialog

const FSM_EXPERT = "State Machine Generator Expert"
const SCRIPT_EXPERT = "Script Generator Expert"

var _animation_tree: AnimationTree
var _target_path: String
var _selected_paths: Array[String]
var _get_animations_callback: Callable
var _get_script_callback: Callable
var _refresh_callback: Callable
var _export_manager: ExportManager
var _experts: Dictionary = {}


func _init(feedback_dialog: FeedbackDialog) -> void:
	self.feedback = feedback_dialog
	_register_experts()

func _register_experts() -> void:
	var fsm_expert = FSMExpert.new(self)
	var script_expert = ScriptGeneratorExpert.new(self)
	
	_experts[fsm_expert.name] = fsm_expert
	_experts[script_expert.name] = script_expert

func execute_ai_action(
	animation_tree: AnimationTree,
	target_path: String,
	selected_paths: Array[String],
	get_animations_callback: Callable,
	get_script_callback: Callable,
	refresh_callback: Callable,
	export_manager: ExportManager
) -> String:
	_animation_tree = animation_tree
	_target_path = target_path
	_selected_paths = selected_paths
	_get_animations_callback = get_animations_callback
	_get_script_callback = get_script_callback
	_refresh_callback = refresh_callback
	_export_manager = export_manager
		
	if _animation_tree == null:
		await feedback.show_info("No AnimationTree selected", "No AnimationTree selected")
		return ""
	
	var selected_blueprint: String = _export_manager.export_tree_as_yaml(_animation_tree, _selected_paths)
	var prompt_dialog = _create_prompt_dialog()
	var apply = await prompt_dialog.show()
	
	if not apply:
		TreeDebug.msg("canceled")
		return ""
	
	TreeDebug.msg("applayed successfully!")
	
	var con_ai: ConAI = ConAI.new()
	var avaible_types = ",".join(prompt_dialog.get_value("node_type").keys().filter(func(key): return prompt_dialog.get_value("node_type")[key]))
	var expert_type = prompt_dialog.get_value("expert")
	var user_input: String = prompt_dialog.get_value("prompt")
	var include_excerpt: bool = prompt_dialog.get_value("include_excerpt")
	var boilerplat: String = _export_manager.generate_animation_tree_boilerplate(_animation_tree, _selected_paths)
	var script_content: String = _get_script_callback.call()
	
	if user_input.is_empty():
		return ""
	
	if _get_script_callback.call().strip_edges().is_empty() or include_excerpt == false:
		script_content = "No excerpt provided"
	
	var expert: Expert = _experts.get(expert_type)
	if expert == null:
		TreeDebug.msg("Expert not found: " + expert_type)
		return ""
	
	var system_prompt_path = AnimationTreeTree.ai_system_prompt_path + expert.get_system_prompt()
	var system_prompt = _build_system_prompt(
		system_prompt_path,
		_target_path,
		_get_animations_callback.call(),
		script_content,
		avaible_types,
		boilerplat,
		selected_blueprint
	)
	
	await expert.process(con_ai, system_prompt, user_input)
	return ""
	
func _create_prompt_dialog() -> ConfigDialog:
	var prompt_fields: Array[ConfigField] = []

	
	prompt_fields.append(ConfigField.new(
		"prompt", 
		"Prompt", 
		"Enter detailed description what you want from the Expert-AI", 
		"General", 
		"string_multi", 
		""
	))
	
	for expert in _experts.values():
		var expert_fields = expert.get_config_fields()
		for field in expert_fields:
			prompt_fields.append(field)
	
	var expert_names: Array[String] = []
	for expert_name in _experts.keys():
		expert_names.append(expert_name)
	
	prompt_fields.append(ConfigField.new(
		"expert", 
		"Which expert you need?", 
		"Based on the expert you have chosen, you get an appropriate result.", 
		"General", 
		"combo_box", 
		expert_names
	))
	
	var warnings: String = ""
	
	if (_get_animations_callback.call() as String).strip_edges().is_empty():
		warnings += "- Your AnimationPlayer has no animations!\n"

	if _get_script_callback.call().strip_edges().is_empty():
		warnings += "- Your ExpressionBaseNodeScript has no boolean types, therefore some experts are going to assume expressions."
	
		
	prompt_fields.append(ConfigField.new(
		"target_info", 
		"Experts are going to assume that you want work at this AnimationTree Node: '%s'. " % [_target_path if !_target_path.is_empty() else "Root"], 
		"Your selection", 
		"General", 
		"callout", 
        "important"
	))
	
	if warnings.is_empty() == false:
		prompt_fields.append(ConfigField.new(
			"prompt_warnings", 
			warnings, 
			"Beaware you have some warnings", 
			"General", 
			"callout", 
	        "warning"
		))
	
	return ConfigDialog.new("prompt.cfg", prompt_fields)

func _build_system_prompt(
	system_prompt_path: String,
	target_path: String,
	avaible_animations: String,
	script_content: String,
	avaible_types: String,
	boilerplate: String,
	blueprint: String
) -> String:
	var systemprompt = _read_file(system_prompt_path)
	
	systemprompt = systemprompt.replace("{{script_excerpt}}", script_content)
	systemprompt = systemprompt.replace("{{target_path}}", target_path)
	systemprompt = systemprompt.replace("{{avaible_animations}}", avaible_animations)
	systemprompt = systemprompt.replace("{{avaible_types}}", avaible_types)
	systemprompt = systemprompt.replace("{{boilerplate}}", boilerplate)
	systemprompt = systemprompt.replace("{{blueprint}}", blueprint)
	systemprompt = systemprompt.replace("{{input_map}}", ",".join(InputMap.get_actions()))
	
	return systemprompt

func _read_file(file_path: String) -> String:
	var script_path = ""
	var stack = get_stack()
	if stack.size() > 0:
		script_path = stack[0].source
	
	var file = FileAccess.open( file_path, FileAccess.READ)
	
	if file == null:
		print("Error reading file: ", FileAccess.get_open_error())
		return ""
	
	var content = file.get_as_text()
	file.close()
	
	return content

func extract_block_from_markdown(text: String, block_name: String) -> Array:
	var regex = RegEx.new()
	regex.compile("```" + block_name + "\\s*\\n([\\s\\S]*?)\\n```")
	
	var blocks = []
	var results = regex.search_all(text)
	
	for result in results:
		blocks.append(result.get_string(1))
	
	return blocks
