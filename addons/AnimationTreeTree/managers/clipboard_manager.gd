# spinalcord
# https://github.com/spinalcord/animation-tree-tree-godot
# 
# This file is part of animation-tree-tree-godot.
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public.
#
# NOTE: The output generated by this addon is not affected by this license.

class_name ClipboardManager
var clipboard_data: Dictionary = {}


func copy_nodes(animation_tree: AnimationTree, node_paths: Array[String]) -> Dictionary:
	if not is_instance_valid(animation_tree) or node_paths.is_empty():
		return {"success": false}
	
	var copied_nodes: Array[Dictionary] = []
	var node_types: Array[String] = []
	
	TreeDebug.msg("=== COPY OPERATION START ===")
	
	# Copy nodes with positions
	for node_path in node_paths:
		var node = _get_node_at_path(animation_tree.tree_root, node_path)
		if not is_instance_valid(node):
			continue
		
		var copied_node = node.duplicate(true)
		if not is_instance_valid(copied_node):
			continue
		
		var original_position = _get_node_position(animation_tree.tree_root, node_path)
		var blend_position = _get_blend_position(animation_tree.tree_root, node_path)
		
		var node_data = {
			"node": copied_node,
			"original_path": node_path,
			"node_type": node.get_class(),
			"node_name": _get_node_name(node_path),
			"original_position": original_position
		}
		
		if blend_position != null:
			node_data["blend_position"] = blend_position
		
		copied_nodes.append(node_data)
		node_types.append(node.get_class())
	
	if copied_nodes.is_empty():
		return {"success": false}
	
	# Calculate relative positions for multi-node operations
	if copied_nodes.size() > 1:
		_calculate_relative_positions(copied_nodes)
	
	# Collect transitions between copied nodes
	var all_transitions: Array[Dictionary] = _collect_transitions(animation_tree, node_paths)
	
	# Store in clipboard
	clipboard_data = {
		"type": "animation_nodes",
		"nodes": copied_nodes,
		"transitions": all_transitions,
		"source_tree_name": animation_tree.name,
		"timestamp": Time.get_unix_time_from_system(),
		"count": copied_nodes.size()
	}
	
	TreeDebug.msg("Copied %d nodes with %d transitions" % [copied_nodes.size(), all_transitions.size()])
	
	# Return display info
	var display_types = node_types[0] if node_types.size() == 1 else str(node_types.size()) + " nodes"
	var first_node_name = copied_nodes[0].get("node_name", "Unknown")
	if copied_nodes.size() > 1:
		first_node_name += " (+" + str(copied_nodes.size() - 1) + " more)"
	
	return {
		"success": true,
		"display_types": display_types,
		"source_tree": animation_tree.name,
		"first_node_name": first_node_name
	}


func paste_nodes(animation_tree: AnimationTree, target_path: String) -> Dictionary:
	if not clipboard_data.has("nodes") or not is_instance_valid(animation_tree):
		return {"pasted_count": 0}
	
	var builder = AnimationTreeBuilder.new(animation_tree)
	var nodes_data = clipboard_data.nodes as Array
	var pasted_count = 0
	
	# Check if target is a container (StateMachine, BlendTree, or BlendSpace)
	var paste_path = target_path
	var target_node = builder.get_node(target_path)
	
	# If target is NOT a container, paste into its parent instead
	if not (target_node is AnimationNodeStateMachine or target_node is AnimationNodeBlendTree or target_node is AnimationNodeBlendSpace1D or target_node is AnimationNodeBlendSpace2D):
		paste_path = NodeUtils.get_parent_path(target_path)
		target_node = builder.get_node(paste_path)
	
	# Track name mapping: original_name -> new_name
	var name_mapping: Dictionary = {}
	
	var base_position = _calculate_base_position(builder, paste_path, nodes_data.size())
	
	# Paste all nodes first
	for i in range(nodes_data.size()):
		var node_data = nodes_data[i] as Dictionary
		var position_to_use = base_position if i == 0 else base_position + node_data.get("relative_offset", Vector2.ZERO)
		var original_name = node_data["node_name"]
		var blend_position = node_data.get("blend_position", null)
		
		# Add node and get the actual used name
		var actual_name = _add_node_with_unique_name(target_node, node_data["node"], original_name, position_to_use, blend_position)
		
		if not actual_name.is_empty():
			name_mapping[original_name] = actual_name
			pasted_count += 1
			TreeDebug.msg("Pasted: %s -> %s" % [original_name, actual_name])
		else:
			TreeDebug.msg("Failed to paste node: " + original_name)
	
	# Restore transitions if we're pasting into a StateMachine
	if target_node is AnimationNodeStateMachine and clipboard_data.has("transitions"):
		_restore_transitions(target_node as AnimationNodeStateMachine, clipboard_data.transitions, name_mapping)
	
	return {"pasted_count": pasted_count}


# Collect all transitions between the copied nodes
func _collect_transitions(animation_tree: AnimationTree, node_paths: Array[String]) -> Array[Dictionary]:
	var transitions: Array[Dictionary] = []
	
	# Find common parent (all nodes must be in same StateMachine)
	if node_paths.is_empty():
		return transitions
	
	var parent_path = NodeUtils.get_parent_path(node_paths[0])
	
	# Verify all nodes share same parent
	for path in node_paths:
		if NodeUtils.get_parent_path(path) != parent_path:
			TreeDebug.msg("Cannot copy transitions: nodes have different parents")
			return transitions
	
	# Get parent StateMachine
	var parent = _get_node_at_path(animation_tree.tree_root, parent_path)
	if not parent is AnimationNodeStateMachine:
		TreeDebug.msg("Parent is not a StateMachine, no transitions to copy")
		return transitions
	
	var sm = parent as AnimationNodeStateMachine
	
	# Extract just the node names from paths
	var node_names: Array[String] = []
	for path in node_paths:
		node_names.append(_get_node_name(path))
	
	# Iterate through all transitions
	var transition_count = sm.get_transition_count()
	for i in range(transition_count):
		var from = sm.get_transition_from(i)
		var to = sm.get_transition_to(i)
		
		# Only copy transitions where BOTH from and to are in our copied nodes
		if from in node_names and to in node_names:
			var trans = sm.get_transition(i)
			transitions.append({
				"from": from,
				"to": to,
				"transition": _copy_transition(trans)
			})
	
	TreeDebug.msg("Collected %d internal transitions" % transitions.size())
	return transitions


# Restore transitions with name mapping
func _restore_transitions(state_machine: AnimationNodeStateMachine, transitions: Array, name_mapping: Dictionary) -> void:
	var restored_count = 0
	
	for trans_data in transitions:
		var original_from = trans_data["from"] as String
		var original_to = trans_data["to"] as String
		var transition = trans_data["transition"] as AnimationNodeStateMachineTransition
		
		# Map original names to new names
		var new_from = name_mapping.get(original_from, original_from)
		var new_to = name_mapping.get(original_to, original_to)
		
		# Verify both nodes exist
		if not state_machine.has_node(new_from):
			TreeDebug.msg("Cannot restore transition: source node not found: " + new_from)
			continue
		
		if not state_machine.has_node(new_to):
			TreeDebug.msg("Cannot restore transition: target node not found: " + new_to)
			continue
		
		# Check if transition already exists
		if state_machine.has_transition(new_from, new_to):
			#TreeDebug.msg("Transition already exists: %s -> %s" % [new_from, new_to])
			#continue
			state_machine.remove_transition(new_from, new_to) # By removing the transition, we replace the transition
			
		
		# Add transition
		state_machine.add_transition(new_from, new_to, transition)
		restored_count += 1
	
	TreeDebug.msg("Restored %d transitions" % restored_count)


# Copy a transition object
func _copy_transition(trans: AnimationNodeStateMachineTransition) -> AnimationNodeStateMachineTransition:
	var new_trans = AnimationNodeStateMachineTransition.new()
	new_trans.switch_mode = trans.switch_mode
	new_trans.advance_mode = trans.advance_mode
	new_trans.advance_condition = trans.advance_condition
	new_trans.advance_expression = trans.advance_expression
	new_trans.xfade_time = trans.xfade_time
	new_trans.priority = trans.priority
	new_trans.reset = trans.reset
	if trans.xfade_curve:
		new_trans.xfade_curve = trans.xfade_curve
	return new_trans


# Add node with unique name and return the actual name used
func _add_node_with_unique_name(container: AnimationNode, node: AnimationNode, base_name: String, position: Vector2, blend_position = null) -> String:
	if not is_instance_valid(container) or not is_instance_valid(node):
		return ""
	
	var unique_name = base_name
	
	if container is AnimationNodeStateMachine:
		var sm = container as AnimationNodeStateMachine
		
		# Find unique name
		var counter = 1
		while sm.has_node(unique_name):
			counter += 1
			unique_name = base_name + str(counter)
			if counter > 1000:
				unique_name = base_name + "_" + str(Time.get_unix_time_from_system())
				break
		
		# Add node
		sm.add_node(unique_name, node, position)
		_emit_changed(sm)
		return unique_name
	
	elif container is AnimationNodeBlendTree:
		var bt = container as AnimationNodeBlendTree
		
		# Find unique name
		var counter = 1
		while is_instance_valid(bt.get_node(unique_name)):
			counter += 1
			unique_name = base_name + str(counter)
			if counter > 1000:
				unique_name = base_name + "_" + str(Time.get_unix_time_from_system())
				break
		
		# Add node
		bt.add_node(unique_name, node, position)
		_emit_changed(bt)
		return unique_name
	
	elif container is AnimationNodeBlendSpace1D:
		var bs1d = container as AnimationNodeBlendSpace1D
		
		# BlendSpace children always use numeric index as name
		unique_name = str(bs1d.get_blend_point_count())
		
		# Determine blend position
		var pos_1d: float = 0.0
		if blend_position != null:
			if blend_position is float or blend_position is int:
				pos_1d = float(blend_position)
			elif blend_position is Vector2:
				pos_1d = (blend_position as Vector2).x
		
		# Add blend point
		bs1d.add_blend_point(node, pos_1d)
		_emit_changed(bs1d)
		return unique_name
	
	elif container is AnimationNodeBlendSpace2D:
		var bs2d = container as AnimationNodeBlendSpace2D
		
		# BlendSpace children always use numeric index as name
		unique_name = str(bs2d.get_blend_point_count())
		
		# Determine blend position
		var pos_2d: Vector2 = Vector2.ZERO
		if blend_position != null:
			if blend_position is Vector2:
				pos_2d = blend_position as Vector2
			elif blend_position is float or blend_position is int:
				pos_2d = Vector2(float(blend_position), 0.0)
		
		# Add blend point
		bs2d.add_blend_point(node, pos_2d)
		_emit_changed(bs2d)
		return unique_name
	
	return ""


# Emit changed signal on a node
func _emit_changed(node: AnimationNode) -> void:
	if node.has_method("emit_changed"):
		node.emit_changed()


func get_status() -> Dictionary:
	if clipboard_data.has("nodes"):
		var node_type_text = str(clipboard_data["count"]) + " nodes" if clipboard_data["count"] > 1 else clipboard_data.nodes[0].get("node_type", "Unknown")
		return {
			"has_content": true,
			"node_type": node_type_text,
			"source_tree": clipboard_data.get("source_tree_name", "Unknown"),
			"original_path": str(clipboard_data["count"]) + " paths"
		}
	return {"has_content": false}


# Helper methods
func _get_node_at_path(root: AnimationNode, path: String) -> AnimationNode:
	if path.is_empty(): return root
	var parts = path.split("/", false)
	var current = root
	for part in parts:
		if current is AnimationNodeStateMachine:
			current = current.get_node(part)
		elif current is AnimationNodeBlendTree:
			current = current.get_node(part)
		elif current is AnimationNodeBlendSpace1D:
			var index = int(part)
			current = current.get_blend_point_node(index)
		elif current is AnimationNodeBlendSpace2D:
			var index = int(part)
			current = current.get_blend_point_node(index)
		if not is_instance_valid(current): return null
	return current


func _get_node_name(path: String) -> String:
	return path.substr(path.rfind("/") + 1) if path.contains("/") else path


func _get_node_position(root: AnimationNode, node_path: String) -> Vector2:
	var parent_path = node_path.substr(0, node_path.rfind("/")) if node_path.contains("/") else ""
	var parent = _get_node_at_path(root, parent_path)
	var node_name = _get_node_name(node_path)
	
	if parent is AnimationNodeStateMachine:
		return parent.get_node_position(node_name)
	elif parent is AnimationNodeBlendTree:
		return parent.get_node_position(node_name)
	return Vector2.ZERO

func _get_blend_position(root: AnimationNode, node_path: String):
	var parent_path = node_path.substr(0, node_path.rfind("/")) if node_path.contains("/") else ""
	var parent = _get_node_at_path(root, parent_path)
	var node_name = _get_node_name(node_path)
	
	if parent is AnimationNodeBlendSpace1D:
		var bs1d = parent as AnimationNodeBlendSpace1D
		# Find the blend point index by name
		for i in range(bs1d.get_blend_point_count()):
			if str(i) == node_name:
				return bs1d.get_blend_point_position(i)
	
	elif parent is AnimationNodeBlendSpace2D:
		var bs2d = parent as AnimationNodeBlendSpace2D
		# Find the blend point index by name
		for i in range(bs2d.get_blend_point_count()):
			if str(i) == node_name:
				return bs2d.get_blend_point_position(i)
	
	return null


func _calculate_relative_positions(copied_nodes: Array) -> void:
	if copied_nodes.size() <= 1: return
	var base_position = copied_nodes[0].get("original_position", Vector2.ZERO)
	for i in range(1, copied_nodes.size()):
		var node_data = copied_nodes[i] as Dictionary
		var node_position = node_data.get("original_position", Vector2.ZERO)
		node_data["relative_offset"] = node_position - base_position


func _calculate_base_position(builder: AnimationTreeBuilder, target_path: String, node_count: int) -> Vector2:
	var target_node = builder.get_node(target_path)
	if target_node is AnimationNodeStateMachine:
		var node_list = target_node.get_node_list()
		if not node_list.is_empty():
			var rightmost = -999999.0
			var avg_y = 0.0
			for name in node_list:
				var pos = target_node.get_node_position(name)
				if pos.x > rightmost: rightmost = pos.x
				avg_y += pos.y
			return Vector2(rightmost + 200, avg_y / node_list.size())
	return Vector2(100, 100)
