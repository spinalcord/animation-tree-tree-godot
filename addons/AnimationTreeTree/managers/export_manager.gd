# spinalcord
# https://github.com/spinalcord/animation-tree-tree-godot
# 
# This file is part of animation-tree-tree-godot.
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public.
#
# NOTE: The output generated by this addon is not affected by this license.

class_name ExportManager
var yaml_formater = BlueprintGenerator.new()
var boilerplate_generator = BoilerplateGenerator.new()

# Add the missing method that calls the boilerplate generator
func export_tree_as_boilerplate(animation_tree: AnimationTree, selected_paths: Array[String] = []) -> String:
	if not animation_tree or not animation_tree.tree_root:
		return "# No Animation Tree\n\nNo AnimationTree selected or tree is empty."
	
	var state_machines: Array[Dictionary] = []
	var blend_spaces: Array[Dictionary] = []
	
	if selected_paths.is_empty():
		# If no selection, use the entire tree
		state_machines = boilerplate_generator.collect_state_machines(animation_tree.tree_root, "")
		blend_spaces = boilerplate_generator.collect_blend_spaces(animation_tree.tree_root, "")
	else:
		# Collect only selected state machines and blend spaces
		state_machines = boilerplate_generator.collect_selected_state_machines(animation_tree.tree_root, "", selected_paths)
		blend_spaces = boilerplate_generator.collect_selected_blend_spaces(animation_tree.tree_root, "", selected_paths)
	
	if state_machines.is_empty() and blend_spaces.is_empty():
		return "# No State Machines or Blend Spaces Found\n\nNo state machines or blend spaces found in selection or tree."
	
	var code = ""
	
	# Generate complete boilerplate with blend spaces
	code += boilerplate_generator.generate_complete_boilerplate(state_machines, blend_spaces)
	
	return code

func export_tree_as_yaml(animation_tree: AnimationTree, selected_paths: Array[String] = []) -> String:
	if not animation_tree or not animation_tree.tree_root:
		return "# NO AnimationTree selected OR tree is empty."
	
	var yaml = ""
	
	# Collect all transitions from the AnimationTree
	var all_transitions = _collect_all_transitions_from_tree(animation_tree.tree_root, "")
	
	# Generate YAML based on selection
	yaml += yaml_formater.format_tree_node_to_yaml(animation_tree.tree_root, "", 0, all_transitions, selected_paths)
	
	return yaml

func _collect_all_transitions_from_tree(root_node: AnimationNode, root_path: String) -> Dictionary:
	var transitions_by_path: Dictionary = {}
	_collect_transitions_recursive(root_node, root_path, transitions_by_path)
	return transitions_by_path

func _collect_transitions_recursive(node: AnimationNode, current_path: String, transitions_dict: Dictionary) -> void:
	if node is AnimationNodeStateMachine:
		var state_machine = node as AnimationNodeStateMachine
		var transitions = _extract_state_machine_transitions(state_machine, current_path)
		if not transitions.is_empty():
			transitions_dict[current_path] = transitions
		
		# Recursively check child states
		var state_names = NodeUtils.get_container_children(state_machine)
		for state_name in state_names:
			var child_path = PathUtils.build_child_path(current_path, state_name)
			var child_node = state_machine.get("states/%s/node" % state_name) as AnimationNode
			if child_node:
				_collect_transitions_recursive(child_node, child_path, transitions_dict)
	
	elif node is AnimationNodeBlendTree:
		var blend_tree = node as AnimationNodeBlendTree
		var node_names = NodeUtils.get_container_children(blend_tree)
		for node_name in node_names:
			if node_name == "output":
				continue
			var child_path = PathUtils.build_child_path(current_path, node_name)
			var child_node = NodeUtils.get_blend_tree_node(blend_tree, node_name)
			if child_node:
				_collect_transitions_recursive(child_node, child_path, transitions_dict)

func _extract_state_machine_transitions(state_machine: AnimationNodeStateMachine, path: String) -> Array[Dictionary]:
	var transitions: Array[Dictionary] = []
	var transition_count = state_machine.get_transition_count()
	
	for i in range(transition_count):
		var from_node = state_machine.get_transition_from(i)
		var to_node = state_machine.get_transition_to(i)
		var transition = state_machine.get_transition(i)
		
		if not is_instance_valid(transition):
			continue
		
		# Reuse existing transition data creation logic
		var transition_data = _create_transition_metadata(i, from_node, to_node, transition, path)
		transitions.append(transition_data)
	
	return transitions

func _create_transition_metadata(index: int, from_node: String, to_node: String, transition: AnimationNodeStateMachineTransition, path: String) -> Dictionary:
	return {
			"type": "transition",
			"index": index,
			"from": from_node,
			"to": to_node,
			"switch_mode": transition.switch_mode,
			"advance_mode": transition.advance_mode,
			"advance_condition": transition.advance_condition,
			"advance_expression": transition.advance_expression,
			"xfade_time": transition.xfade_time,
			"xfade_curve": transition.xfade_curve,
			"priority": transition.priority,
			"reset": transition.reset,
			"transition_object": transition,
			"full_path": path + "/transitions/" + str(index)
		}
# Utility classes
