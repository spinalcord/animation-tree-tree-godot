# spinalcord
# https://github.com/spinalcord/animation-tree-tree-godot
# 
# This file is part of animation-tree-tree-godot.
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public.
#
# NOTE: The output generated by this addon is not affected by this license.

class_name TreeManager

func populate_tree_view(tree_view: Tree, root_node: AnimationNode) -> void:
	TreeDebug.msg("Refreshing tree view for: %s" % root_node.get_class())
	
	var root_item: TreeItem = tree_view.create_item()
	root_item.set_text(0, "Root (%s)" % root_node.get_class())
	root_item.set_metadata(0, "")
	
	_populate_tree_item(root_node, root_item, "")

func _populate_tree_item(node: AnimationNode, tree_item: TreeItem, path: String) -> void:
	TreeDebug.msg("Populating node: %s at path: %s" % [node.get_class(), path])
	
	if node is AnimationNodeStateMachine:
		_populate_state_machine(node as AnimationNodeStateMachine, tree_item, path)
	elif node is AnimationNodeBlendTree:
		_populate_blend_tree(node as AnimationNodeBlendTree, tree_item, path)
	elif node is AnimationNodeBlendSpace1D:
		_populate_blend_space_1d(node as AnimationNodeBlendSpace1D, tree_item, path)
	elif node is AnimationNodeBlendSpace2D:
		_populate_blend_space_2d(node as AnimationNodeBlendSpace2D, tree_item, path)
	else:
		TreeDebug.msg("Unknown node type or leaf node: %s" % node.get_class())

func _populate_state_machine(state_machine: AnimationNodeStateMachine, tree_item: TreeItem, path: String) -> void:
	var state_names = NodeUtils.get_container_children(state_machine)
	TreeDebug.msg("Got states via property inspection: %s" % str(state_names))
	
	# Add states
	for state_name in state_names:
		var child_path = PathUtils.build_child_path(path, state_name)
		var state_node = state_machine.get("states/%s/node" % state_name) as AnimationNode
		_add_tree_item(tree_item, state_name, state_node, child_path)

func _populate_blend_tree(blend_tree: AnimationNodeBlendTree, tree_item: TreeItem, path: String) -> void:
	TreeDebug.msg("Processing BlendTree node...")
	
	var node_names = NodeUtils.get_container_children(blend_tree)
	TreeDebug.msg("Found BlendTree node names: %s" % str(node_names))
	
	for node_name in node_names:
		if node_name == "output":
			continue
		
		var child_path = PathUtils.build_child_path(path, node_name)
		var blend_node = NodeUtils.get_blend_tree_node(blend_tree, node_name)
		_add_tree_item(tree_item, node_name, blend_node, child_path)

func _populate_blend_space_1d(blend_space: AnimationNodeBlendSpace1D, tree_item: TreeItem, path: String) -> void:
	TreeDebug.msg("Processing BlendSpace1D node...")
	
	var blend_point_count = blend_space.get_blend_point_count()
	
	for i in range(blend_point_count):
		var point_node = blend_space.get_blend_point_node(i)
		var point_position = blend_space.get_blend_point_position(i)
		
		# Try to get a meaningful name from the node
		var node_name = str(i)
		var child_path = PathUtils.build_child_path(path, "%d" % i)
		
		_add_tree_item(tree_item, node_name, point_node, child_path, i, point_position)

func _populate_blend_space_2d(blend_space: AnimationNodeBlendSpace2D, tree_item: TreeItem, path: String) -> void:
	TreeDebug.msg("Processing BlendSpace2D node...")
	
	var blend_point_count = blend_space.get_blend_point_count()
	
	for i in range(blend_point_count):
		var point_node = blend_space.get_blend_point_node(i)
		var point_position = blend_space.get_blend_point_position(i)
		
		# Try to get a meaningful name from the node
		var node_name = str(i)
		var child_path = PathUtils.build_child_path(path, "%d" % i)
		
		_add_tree_item(tree_item, node_name, point_node, child_path, i, point_position)

func _add_tree_item(
	parent_item: TreeItem, 
	node_name: String, 
	node: AnimationNode, 
	path: String,
	blend_point_index: int = -1,
	blend_position: Variant = null
) -> void:
	var child_item: TreeItem = parent_item.create_child()
	
	if node:
		child_item.set_text(0, "%s (%s)" % [node_name, node.get_class()])
		child_item.set_metadata(0, MetadataUtils.create_node_metadata(
			path, 
			node.get_class(), 
			node_name, 
			_can_have_children(node),
			blend_point_index,
			blend_position
		))
		
		if _can_have_children(node):
			_populate_tree_item(node, child_item, path)
	else:
		child_item.set_text(0, "%s Node" % node_name)
		child_item.set_metadata(0, MetadataUtils.create_node_metadata(
			path, 
			"NULL", 
			node_name, 
			false,
			blend_point_index,
			blend_position
		))
		
func _can_have_children(node: AnimationNode) -> bool:
	return (node is AnimationNodeStateMachine or 
			node is AnimationNodeBlendTree or 
			node is AnimationNodeBlendSpace1D or 
			node is AnimationNodeBlendSpace2D)
