# spinalcord
# https://github.com/spinalcord/animation-tree-tree-godot
# 
# This file is part of animation-tree-tree-godot.
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public.
#
# NOTE: The output generated by this addon is not affected by this license.

# animation_tree_dock.gd
@tool
class_name AnimationTreeDock
extends Control

signal copy_requested(animation_tree: AnimationTree, node_paths: Array[String])
signal paste_requested(animation_tree: AnimationTree, target_path: String)
signal delete_requested(animation_tree: AnimationTree, node_paths: Array[String])
signal merge_requested(animation_tree: AnimationTree, node_paths: Array[String])

var tree_view: Tree
var selected_animation_tree: AnimationTree
var path_label: Label
var status_label: Label
var clipboard_status_label: Label

# Button dictionary for dynamic button management
var buttons: Dictionary = {}

# Managers
var ui_manager: UIManager
var tree_manager: TreeManager
var state_manager: StateManager
var export_manager: ExportManager
var ai_manager: AIManager
var editor_selection: EditorSelection
var feedback: FeedbackDialog

func _init() -> void:
	name = "AnimationTree-Tree"
	_reload_config()
	_initialize_managers()
	_create_ui()
	_setup_auto_detection()

func _reload_config():
	AnimationTreeTree.plugin_config.load(AnimationTreeTree.config_path_with_filename)

func _initialize_managers() -> void:
	ui_manager = UIManager.new()
	tree_manager = TreeManager.new()
	state_manager = StateManager.new()
	export_manager = ExportManager.new()
	feedback = FeedbackDialog.new()
	ai_manager = AIManager.new(feedback)

# Get button configuration with Callables
func _get_button_config() -> Array:
	return [
		{
			"name": "copy_button",
			"icon": "ActionCopy",
			"tooltip": "Copy selected node",
			"handler": _on_copy_pressed,
			"disabled": true
		},
		{
			"name": "paste_button",
			"icon": "ActionPaste",
			"tooltip": "Paste node to selected location",
			"handler": _on_paste_pressed,
			"disabled": true
		},
		{
			"name": "delete_button",
			"icon": "Remove",
			"tooltip": "Delete selected node",
			"handler": _on_delete_pressed,
			"disabled": true
		},
		{
			"name": "merge_button",
			"icon": "Groups",
			"tooltip": "Merge selected nodes into StateMachine",
			"handler": _on_merge_pressed,
			"disabled": true
		},
		{
			"name": "blueprint_button",
			"icon": "FileList",
			"tooltip": "Print slected node structure as yaml blueprint",
			"handler": _on_blueprint_pressed,
			"disabled": false
		},
		{
			"name": "boilerplate_button",
			"icon": "Script",
			"tooltip": "Generate boilerplate code based on selection",
			"handler": _on_boilerplate_pressed,
			"disabled": false
		},
		{
			"name": "settings_button",
			"icon": "Tools",
			"tooltip": "Open settings",
			"handler": _on_settings_pressed,
			"disabled": false
		},
		{
			"name": "ai_button",
			"icon": "Play",
			"tooltip": "AI Actions",
			"handler": _on_ai_pressed,
			"disabled": false
		}
	]

func _create_ui() -> void:
	var components = ui_manager.create_dock_ui(_get_button_config())
	
	# Store UI component references
	status_label = components.status_label
	clipboard_status_label = components.clipboard_status_label
	path_label = components.path_label
	tree_view = components.tree_view
	
	# Store button references
	buttons = components.buttons
	
	# Connect tree view signal
	tree_view.item_selected.connect(_on_tree_item_selected)
	
	# Add to dock
	add_child(components.main_container)

func _get_animation_player() -> AnimationPlayer:
	if selected_animation_tree == null:
		return null
	
	var anim_player_path = selected_animation_tree.anim_player
	if selected_animation_tree.anim_player != NodePath():
		return selected_animation_tree.get_node(selected_animation_tree.anim_player) as AnimationPlayer
	return null

func _get_expression_base_node() -> String:
	var node = selected_animation_tree.get_node(selected_animation_tree.advance_expression_base_node)
	if node:
		var current_script = node.get_script()
		if current_script:
			var script_content = FileAccess.get_file_as_string(current_script.resource_path)
			var shortened = _shorten_script(script_content)
			return shortened
	
	return ""

func _shorten_script(content: String) -> String:
	var lines = content.split("\n")
	var result = []
	var regex = RegEx.new()
	regex.compile("(->|:)\\s*bool\\s")
	
	for line in lines:
		var trimmed = line.strip_edges()
		
		# Skip comments
		if trimmed.begins_with("#"):
			continue
		
		# Check if line is not indented (class level)
		var current_indent = len(line) - len(line.lstrip("\t"))
		
		# Check if line contains -> bool or : bool
		if current_indent == 0 and regex.search(line):
			result.append(line)
	
	return "\n".join(result)


func get_avaible_animations() -> String:
	if _get_animation_player() == null:
		await feedback.show_info("Your AnimationTree has no AnimationPlayer. Your AnimationTree needs an AnimationPlayer.", "AnimationPlayer missing")
		return ""
	
	var animations = _get_animation_player().get_animation_list()

	var filtered = []
	for anim in animations:
		if anim != "RESET":
			filtered.append(anim)
	var avaible_animations: String = ",".join(filtered)
	return avaible_animations

func extract_block_from_markdown(text: String, block_name: String) -> Array:
	var regex = RegEx.new()
	regex.compile("```" +block_name+"\\s*\\n([\\s\\S]*?)\\n```")
	
	var yaml_blocks = []
	var results = regex.search_all(text)
	
	for result in results:
		yaml_blocks.append(result.get_string(1))
	
	return yaml_blocks

func _on_ai_pressed():
	var selected_item: TreeItem = tree_view.get_selected()
	var target_path: String = ""
	if selected_item != null:
		target_path = MetadataUtils.get_path_from_metadata(selected_item.get_metadata(0))
		target_path = _get_container_path(target_path)
	
	await ai_manager.execute_ai_action(
		selected_animation_tree,
		target_path,
		_get_selected_node_paths(),
		get_avaible_animations,
		_get_expression_base_node,
		_refresh_tree_view,
		export_manager
	)
	
	

func _ensure_gitignore_exists() -> void:
	var gitignore_path = AnimationTreeTree.config_path + ".gitignore"
	
	# Check if .gitignore already exists
	if FileAccess.file_exists(gitignore_path):
		return
	
	# Create .gitignore with pattern for .cfg files
	var file = FileAccess.open(gitignore_path, FileAccess.WRITE)
	if file == null:
		await feedback.show_info("Gitignore Error", "Could not create .gitignore file at: " + gitignore_path + "\n. Make sure .gitignore exists to protect your API key.")
		return
	
	file.store_string(
		"# Ignore all config files\n" +
		"*.cfg\n" +
		"# Ignore environment files\n" +
		"*.env\n"
	)
	file.close()
	
	await feedback.show_info("Gitignore Created", ".gitignore file was created successfully in:\n" + AnimationTreeTree.config_path + ". This will prevent that your API key is visible on commits.")

# Bessere Dialog-Verwaltung - Dialog immer neu erstellen
func _on_settings_pressed() -> void:
	_ensure_gitignore_exists()
	var fields: Array[ConfigField] = []
	
	fields.append(ConfigField.new(
		"debug_everything", 
		"Detailed Debug Information", 
		"Output very detailed debug information, what happens.", 
		"Debug", 
		"bool", 
		false
	))
	
	fields.append(ConfigField.new(
		"model", 
		"Model", 
		"The model identifier to use. use \"local-model\" for loaded LM-Studio model.", 
		"API Settings", 
		"string", 
		"local-model"
	))

	fields.append(ConfigField.new(
		"temperature", 
		"Temperature", 
		"A lower value will result in very predictable answers. A higher value leads to more freely responses, often yielding surprising, imaginative.", 
		"API Settings", 
		"float", 
		[0.0, 0.1, 0.7, 2.0]
	))

	fields.append(ConfigField.new(
		"max_tokens", 
		"Max Tokens", 
		"Maximum number of tokens per response", 
		"API Settings", 
		"int", 
		[100, 60000, 100000]
	))

	fields.append(ConfigField.new(
		"base_url", 
		"Base URL", 
		"API endpoint URL", 
		"API Settings", 
		"string", 
		"http://localhost:1234"
	))

	fields.append(ConfigField.new(
		"context_window_slide_size", 
		"Context Window Slide Size", 
		"Number of messages to keep in sliding window. Fully implemented will be used in other version iterations.", 
		"API Settings", 
		"int", 
		[1, 15, 50]
	))

	fields.append(ConfigField.new(
		"api_key", 
		"API Key", 
		"Your API key for authentication", 
		"API Settings", 
		"string_multi", 
		""
	))

	var config_dialog: ConfigDialog = ConfigDialog.new(AnimationTreeTree.config_name, fields)
	var saved = await config_dialog.show()
	
	if saved:
		_reload_config()

func _setup_auto_detection() -> void:
	editor_selection = EditorInterface.get_selection()
	if editor_selection:
		editor_selection.selection_changed.connect(_on_editor_selection_changed)
	EditorInterface.get_editor_undo_redo().history_changed.connect(_on_editor_selection_changed)
	_detect_selected_animation_tree()

func _detect_selected_animation_tree() -> void:
	if not editor_selection:
		return
	
	var selected_nodes: Array[Node] = editor_selection.get_selected_nodes()
	for node in selected_nodes:
		if node is AnimationTree:
			TreeDebug.msg("Auto-detected AnimationTree: %s" % node.name)
			_set_animation_tree(node as AnimationTree)
			return
	
	TreeDebug.msg("No AnimationTree in current selection")

func _on_editor_selection_changed() -> void:
	var selection = EditorInterface.get_selection()
	var selected_nodes = selection.get_selected_nodes()
	
	for node in selected_nodes:
		if node is AnimationTree:
			_detect_selected_animation_tree()

func _set_animation_tree(tree: AnimationTree) -> void:
	selected_animation_tree = tree
	
	if not tree or not tree.tree_root:
		ui_manager.set_status(status_label, "AnimationTree has no tree_root", Color.YELLOW)
		return
	
	ui_manager.set_status(status_label, "%s ✓" % tree.name, Color.GREEN)
	ui_manager.enable_controls([buttons.copy_button, buttons.delete_button, buttons.merge_button], true)
	_refresh_tree_view()

# 5. Füge den neuen Event-Handler hinzu:
func _on_merge_pressed() -> void:
	var node_paths = _get_selected_node_paths()
	if node_paths.size() < 2:
		TreeDebug.msg("Need at least 2 nodes selected for merge")
		return
	
	if not selected_animation_tree:
		return
	
	merge_requested.emit(selected_animation_tree, node_paths)

func _refresh_tree_view() -> void:
	tree_view.clear()
	
	if not selected_animation_tree or not selected_animation_tree.tree_root:
		TreeDebug.msg("No AnimationTree or tree_root found")
		return
	
	tree_manager.populate_tree_view(tree_view, selected_animation_tree.tree_root)

func update_clipboard_status(has_content: bool, node_type: String = "", source_tree_name: String = "", node_name: String = "") -> void:
	ui_manager.update_clipboard_status(clipboard_status_label, buttons.paste_button, has_content, node_type, source_tree_name, node_name, selected_animation_tree != null)

func _on_tree_item_selected() -> void:
	var selected_item: TreeItem = tree_view.get_selected()
	if not selected_item:
		ui_manager.set_path_display(path_label, "No selection", Color.GRAY)
		return
	
	var item_path = MetadataUtils.get_path_from_metadata(selected_item.get_metadata(0))
	var display_text = item_path if not item_path.is_empty() else "Root"
	ui_manager.set_path_display(path_label, display_text, Color.WHITE)

func _on_copy_pressed() -> void:
	var node_paths = _get_selected_node_paths()
	if node_paths.is_empty() or not selected_animation_tree:
		return
	copy_requested.emit(selected_animation_tree, node_paths)

func _on_paste_pressed() -> void:
	var selected_item: TreeItem = tree_view.get_selected()
	if not selected_item or not selected_animation_tree:
		return
	
	var target_path = MetadataUtils.get_path_from_metadata(selected_item.get_metadata(0))
	paste_requested.emit(selected_animation_tree, target_path)

func _on_delete_pressed() -> void:
	var node_paths = _get_selected_node_paths()
	if node_paths.is_empty() or not selected_animation_tree:
		return
	delete_requested.emit(selected_animation_tree, node_paths)

func _on_blueprint_pressed() -> void:
	var node_paths = _get_selected_node_paths()
	if not selected_animation_tree:
		TreeDebug.msg("No AnimationTree selected")
		return
	
	var yaml_output: String
	if node_paths.is_empty():
		TreeDebug.msg("No nodes selected, generating YAML for entire tree")
		yaml_output = export_manager.export_tree_as_yaml(selected_animation_tree, [])
	else:
		yaml_output = export_manager.export_tree_as_yaml(selected_animation_tree, node_paths)
	await feedback.show_text("YAML Export", "Animation Tree YAML", yaml_output, true)

func _on_boilerplate_pressed() -> void:
	var node_paths = _get_selected_node_paths()
	if not selected_animation_tree:
		TreeDebug.msg("No AnimationTree selected")
		return
	
	var boilerplate = await feedback.show_text("Boilerplate", "Boilerplate of selected nodes",export_manager.generate_animation_tree_boilerplate(selected_animation_tree, node_paths), true)

func _get_selected_node_paths() -> Array[String]:
	var selected_items = SelectionUtils.get_selected_items(tree_view)
	var node_paths: Array[String] = []
	
	for item in selected_items:
		var path = MetadataUtils.get_path_from_metadata(item.get_metadata(0))
		if not path.is_empty():  # Skip root nodes for delete
			node_paths.append(path)
	
	return node_paths



func update_tree_view_after_operation() -> void:
	var current_state = state_manager.capture_tree_state(tree_view)
	await get_tree().process_frame
	
	_refresh_tree_view()
	await get_tree().process_frame
	
	state_manager.restore_tree_state(tree_view, current_state)

func _get_container_path(path: String) -> String:
	if path.is_empty():
		return path
	
	var node = NodeUtils.get_node_at_path(selected_animation_tree.tree_root, path)
	if not is_instance_valid(node):
		return path
	
	if node is AnimationNodeStateMachine or node is AnimationNodeBlendTree or node is AnimationNodeBlendSpace1D or node is AnimationNodeBlendSpace2D:
		return path
	
	return NodeUtils.get_parent_path(path)

func _exit_tree() -> void:
	if editor_selection and editor_selection.selection_changed.is_connected(_on_editor_selection_changed):
		editor_selection.selection_changed.disconnect(_on_editor_selection_changed)
