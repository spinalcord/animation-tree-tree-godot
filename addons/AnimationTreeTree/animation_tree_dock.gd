# spinalcord
# https://github.com/spinalcord/animation-tree-tree-godot
# 
# This file is part of animation-tree-tree-godot.
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public.
#
# NOTE: The output generated by this addon is not affected by this license.

# animation_tree_dock.gd
@tool
class_name AnimationTreeDock
extends Control

signal copy_requested(animation_tree: AnimationTree, node_paths: Array[String])
signal paste_requested(animation_tree: AnimationTree, target_path: String)
signal delete_requested(animation_tree: AnimationTree, node_paths: Array[String])
signal merge_requested(animation_tree: AnimationTree, node_paths: Array[String])

var tree_view: Tree
var selected_animation_tree: AnimationTree
var path_label: Label
var status_label: Label
var clipboard_status_label: Label

# Button dictionary for dynamic button management
var buttons: Dictionary = {}

# Managers
var ui_manager: UIManager
var tree_manager: TreeManager
var state_manager: StateManager
var export_manager: ExportManager
var ai_manager: AIManager
var editor_selection: EditorSelection
var feedback: FeedbackDialog = FeedbackDialog.new()

func _ready() -> void:
	_initialize_managers()
	_create_ui()
	_setup_auto_detection()

func _init() -> void:
	name = "AnimationTree-Tree"
	_reload_config()

func _reload_config():
	AnimationTreeTree.plugin_config.load(AnimationTreeTree.config_path_with_filename)

func _initialize_managers() -> void:
	ui_manager = UIManager.new()
	tree_manager = TreeManager.new()
	state_manager = StateManager.new()
	ai_manager = AIManager.new()

# Get button configuration with Callables
func _get_button_config() -> Array:
	return [
		{
			"name": "copy_button",
			"icon": "ActionCopy",
			"tooltip": "Copy selected node",
			"handler": _on_copy_pressed,
			"disabled": true
		},
		{
			"name": "paste_button",
			"icon": "ActionPaste",
			"tooltip": "Paste node to selected location",
			"handler": _on_paste_pressed,
			"disabled": true
		},
		{
			"name": "delete_button",
			"icon": "Remove",
			"tooltip": "Delete selected node",
			"handler": _on_delete_pressed,
			"disabled": true
		},
		{
			"name": "merge_button",
			"icon": "Groups",
			"tooltip": "Merge selected nodes into StateMachine",
			"handler": _on_merge_pressed,
			"disabled": true
		},
		{
			"name": "blueprint_button",
			"icon": "FileList",
			"tooltip": "Print slected node structure as yaml blueprint",
			"handler": _on_blueprint_pressed,
			"disabled": false
		},
		{
			"name": "boilerplate_button",
			"icon": "Script",
			"tooltip": "Generate boilerplate code based on selection",
			"handler": _on_boilerplate_pressed,
			"disabled": false
		},
		{
			"name": "settings_button",
			"icon": "Tools",
			"tooltip": "Open settings",
			"handler": _on_settings_pressed,
			"disabled": false
		},
		{
			"name": "ai_button",
			"icon": "Play",
			"tooltip": "AI Actions",
			"handler": _on_ai_pressed,
			"disabled": false
		}
		
				
	]



func create_backup() -> String:
	if selected_animation_tree == null or selected_animation_tree.owner == null:
		return ""
	if AnimationTreeTree.plugin_config.get_value("settings", "allow_backup", true) == false:
		return ""
	
	var source_path: String = selected_animation_tree.owner.scene_file_path
	var backup_dir: String = "res://backups/treetree/"
	var max_backups: int = AnimationTreeTree.plugin_config.get_value("settings", "max_backup_count", 10)
	
	# Extract filename without path and extension
	var filename = source_path.get_file().get_basename()
	var extension = source_path.get_extension()
	
	# Ensure backup directory exists
	DirAccess.make_dir_recursive_absolute(backup_dir)
	
	# Collect all existing backups with their numbers
	var existing_backups: Array[Dictionary] = []
	var dir = DirAccess.open(backup_dir)
	
	if dir:
		dir.list_dir_begin()
		var file_name = dir.get_next()
		
		while file_name != "":
			if not dir.current_is_dir() and file_name.ends_with("_" + filename + "." + extension):
				# Extract number from filename (e.g. "00001_Player_show.tscn")
				var number_str = file_name.split("_")[0]
				var number = number_str.to_int()
				existing_backups.append({
					"number": number,
					"filename": file_name,
					"path": backup_dir + file_name
				})
			
			file_name = dir.get_next()
		
		dir.list_dir_end()
	
	# Sort backups by number (ascending)
	existing_backups.sort_custom(func(a, b): return a.number < b.number)
	
	# Delete oldest backups if limit is reached
	while existing_backups.size() >= max_backups:
		var oldest = existing_backups[0]
		DirAccess.remove_absolute(oldest.path)
		print("Deleted old backup: ", oldest.filename)
		existing_backups.remove_at(0)
	
	# Determine next backup number
	var next_number = 1
	if existing_backups.size() > 0:
		next_number = existing_backups[-1].number + 1
	
	# Create new backup with next number (5 digits with leading zeros)
	var backup_filename = "%05d_%s.%s" % [next_number, filename, extension]
	var backup_path = backup_dir + backup_filename
	
	# Copy the file
	DirAccess.copy_absolute(source_path, backup_path)
	
	print("Backup created: ", backup_path)
	EditorInterface.get_resource_filesystem().scan()
	return backup_path

# Usage
var backup_path = create_backup()

func _create_ui() -> void:
	var components = ui_manager.create_dock_ui(_get_button_config())
	
	# Store UI component references
	status_label = components.status_label
	clipboard_status_label = components.clipboard_status_label
	path_label = components.path_label
	tree_view = components.tree_view
	
	# Store button references
	buttons = components.buttons
	
	# Connect tree view signal
	tree_view.item_selected.connect(_on_tree_item_selected)
	
	# Add to dock
	add_child(components.main_container)

func _get_animation_player() -> AnimationPlayer:
	if selected_animation_tree == null:
		return null
	
	var anim_player_path = selected_animation_tree.anim_player
	if selected_animation_tree.anim_player != NodePath():
		return selected_animation_tree.get_node(selected_animation_tree.anim_player) as AnimationPlayer
	return null

func _get_expression_base_node() -> String:
	if selected_animation_tree == null:
		return ""
	var node = selected_animation_tree.get_node(selected_animation_tree.advance_expression_base_node)
	if node:
		var current_script = node.get_script()
		if current_script:
			var script_content = FileAccess.get_file_as_string(current_script.resource_path)
			var shortened = _shorten_script(script_content)
			return shortened
	
	return ""

func _shorten_script(content: String) -> String:
	var lines = content.split("\n")
	var result = []
	var in_class = false
	var class_indent = 0
	
	# Regex patterns for different elements
	var func_regex = RegEx.new()
	func_regex.compile("^func\\s+\\w+")
	
	var void_func_regex = RegEx.new()
	void_func_regex.compile("->\\s*void\\s*:")
	
	var var_regex = RegEx.new()
	var_regex.compile("^(var|const|@export|@onready)\\s+")
	
	var class_regex = RegEx.new()
	class_regex.compile("^class_name\\s+\\w+")
	
	var animation_node_regex = RegEx.new()
	animation_node_regex.compile(":\\s*AnimationNode")
	
	for line in lines:
		var trimmed = line.strip_edges()
		
		# Skip empty lines and comments
		if trimmed.is_empty() or trimmed.begins_with("#"):
			continue
		
		# Calculate indentation level
		var indent = len(line) - len(line.lstrip("\t"))
		
		# Class declaration
		if class_regex.search(trimmed):
			result.append(line)
			in_class = true
			class_indent = indent
			continue
		
		# Only process top-level (class-level) declarations
		if indent == 0 or (in_class and indent == class_indent):
			var clean_line = line
			
			# Remove inline comments
			var comment_pos = line.find("#")
			if comment_pos != -1:
				clean_line = line.substr(0, comment_pos).rstrip(" \t")
			
			# Skip AnimationNode variables
			if animation_node_regex.search(clean_line):
				continue
			
			# Skip void functions
			if func_regex.search(trimmed) and void_func_regex.search(clean_line):
				continue
			
			# Class-level variables and exports
			if var_regex.search(trimmed):
				result.append(clean_line)
			# Function signatures
			elif func_regex.search(trimmed):
				result.append(clean_line)
	
	return "\n".join(result)

func get_avaible_animations() -> Array[String]:
	if _get_animation_player() == null:
		await feedback.show_info("Your AnimationTree has no AnimationPlayer. Your AnimationTree needs an AnimationPlayer.", "AnimationPlayer missing")
		return []
	
	var animations = _get_animation_player().get_animation_list()

	var filtered: Array[String] = []
	for anim in animations:
		if anim != "RESET":
			filtered.append(anim)
	return filtered

func extract_block_from_markdown(text: String, block_name: String) -> Array:
	var regex = RegEx.new()
	regex.compile("```" +block_name+"\\s*\\n([\\s\\S]*?)\\n```")
	
	var yaml_blocks = []
	var results = regex.search_all(text)
	
	for result in results:
		yaml_blocks.append(result.get_string(1))
	
	return yaml_blocks

func _dependencies() -> DependencyContainer:
	var selected_item: TreeItem = tree_view.get_selected()
	var target_path: String = ""
	if selected_item != null:
		target_path = MetadataUtils.get_path_from_metadata(selected_item.get_metadata(0))
		target_path = _get_parent_path(target_path)
		
	var container: DependencyContainer = DependencyContainer.new()
	container.bind("CurrentAnimationTree", selected_animation_tree)
	container.bind("TargetPath", target_path)
	container.bind("AvaibleAnimations", await get_avaible_animations())
	container.bind("CurrentExpressionBaseNodeScript", _get_expression_base_node())
	container.bind("SelectedNodePaths", _get_selected_node_paths())
	container.bind("SelectedNodeParentPaths", _get_selected_node_parent_paths())
	container.bind("AllNodeParentPaths", _get_all_parents_node_paths())
	container.bind("TreeView", tree_view)
	return container


func _on_ai_pressed():
	await ai_manager.execute_ai_action(await _dependencies(), create_backup)
	
	_refresh_tree_view()

func _ensure_gitignore_exists() -> void:
	var gitignore_path = AnimationTreeTree.config_path + ".gitignore"
	
	# Check if .gitignore already exists
	if FileAccess.file_exists(gitignore_path):
		return
	
	# Create .gitignore with pattern for .cfg files
	var file = FileAccess.open(gitignore_path, FileAccess.WRITE)
	if file == null:
		await feedback.show_info("Gitignore Error", "Could not create .gitignore file at: " + gitignore_path + "\n. Make sure .gitignore exists to protect your API key.")
		return
	
	file.store_string(
		"# Ignore all config files\n" +
		"*.cfg\n" +
		"# Ignore environment files\n" +
		"*.env\n"
	)
	file.close()
	
	await feedback.show_info("Gitignore Created", ".gitignore file was created successfully in:\n" + AnimationTreeTree.config_path + ". This will prevent that your API key is visible on commits.")

func _on_settings_pressed() -> void:
	_ensure_gitignore_exists()
	var fields: Array[ConfigField] = []
	
	fields.append(ConfigField.new(
		"model", 
		"Model", 
		"The model identifier to use. use \"local-model\" for loaded LM-Studio model.", 
		"API Settings", 
		"string", 
		"local-model"
	))

	fields.append(ConfigField.new(
		"temperature", 
		"Temperature", 
		"A lower value will result in very predictable answers. A higher value leads to more freely responses, often yielding surprising, imaginative.", 
		"API Settings", 
		"float", 
		[0.0, 0.1, 0.7, 2.0]
	))

	fields.append(ConfigField.new(
		"max_tokens", 
		"Max Tokens", 
		"Maximum number of tokens per response", 
		"API Settings", 
		"int", 
		[100, 60000, 100000]
	))

	fields.append(ConfigField.new(
		"base_url", 
		"Base URL", 
		"API endpoint URL", 
		"API Settings", 
		"string", 
		"http://localhost:1234"
	))

	fields.append(ConfigField.new(
		"context_window_slide_size", 
		"Context Window Slide Size", 
		"Number of messages to keep in sliding window. Fully implemented will be used in other version iterations.", 
		"API Settings", 
		"int", 
		[1, 15, 50]
	))

	fields.append(ConfigField.new(
		"api_key", 
		"API Key", 
		"Your API key for authentication", 
		"API Settings", 
		"string_multi", 
		""
	))
	
	fields.append(ConfigField.new(
		"allow_backup", 
		"Allow Backup", 
		"This will create a Backup of your scene, where your AnimationTree is, when you are using critical actions (Merge and AI).", 
		"Backup", 
		"bool", 
		true
	))
	
	fields.append(ConfigField.new(
	"max_backup_count", 
	"Max Backup Count", 
	"Maximum number of backups to keep (sliding window). Oldest backups will be deleted automatically.", 
	"Backup", 
	"int", 
	[2, 6, 20]
	))
	
	fields.append(ConfigField.new(
		"debug_everything", 
		"Detailed Debug Information", 
		"Output very detailed debug information, what happens.", 
		"Debug", 
		"bool", 
		false
	))
	
	fields.append(ConfigField.new(
		"debug_system_prompt", 
		"Debug System Prompt", 
		"Outputs the system prompt in the prompt dialog instead of doing ai actions.", 
		"Debug", 
		"bool", 
		false
	))

	var config_dialog: ConfigDialog = ConfigDialog.new(AnimationTreeTree.config_name, fields)
	var saved = await config_dialog.show()
	
	if saved:
		_reload_config()

func _setup_auto_detection() -> void:
	editor_selection = EditorInterface.get_selection()
	if editor_selection:
		editor_selection.selection_changed.connect(_on_editor_selection_changed)
	EditorInterface.get_editor_undo_redo().history_changed.connect(_on_editor_selection_changed)
	_detect_selected_animation_tree()

func _detect_selected_animation_tree() -> void:
	if not editor_selection:
		return
	
	var selected_nodes: Array[Node] = editor_selection.get_selected_nodes()
	for node in selected_nodes:
		if node is AnimationTree:
			TreeDebug.msg("Auto-detected AnimationTree: %s" % node.name)
			_set_animation_tree(node as AnimationTree)
			return
	
	TreeDebug.msg("No AnimationTree in current selection")

func _on_editor_selection_changed() -> void:
	var selection = EditorInterface.get_selection()
	var selected_nodes = selection.get_selected_nodes()
	
	for node in selected_nodes:
		if node is AnimationTree:
			_detect_selected_animation_tree()

func _set_animation_tree(tree: AnimationTree) -> void:
	selected_animation_tree = tree
	
	if not tree or not tree.tree_root:
		ui_manager.set_status(status_label, "AnimationTree has no tree_root", Color.YELLOW)
		return
	
	ui_manager.set_status(status_label, "%s ✓" % tree.name, Color.GREEN)
	ui_manager.enable_controls([buttons.copy_button, buttons.delete_button, buttons.merge_button], true)
	_refresh_tree_view()

func _on_merge_pressed() -> void:
	var node_paths = _get_selected_node_paths()
	if node_paths.size() < 2:
		TreeDebug.msg("Need at least 2 nodes selected for merge")
		return
	
	if not selected_animation_tree:
		return
	
	create_backup()
	merge_requested.emit(selected_animation_tree, node_paths)

func _refresh_tree_view() -> void:
	tree_view.clear()
	
	if not selected_animation_tree or not selected_animation_tree.tree_root:
		TreeDebug.msg("No AnimationTree or tree_root found")
		return
	
	tree_manager.populate_tree_view(tree_view, selected_animation_tree.tree_root)

func update_clipboard_status(has_content: bool, node_type: String = "", source_tree_name: String = "", node_name: String = "") -> void:
	ui_manager.update_clipboard_status(clipboard_status_label, buttons.paste_button, has_content, node_type, source_tree_name, node_name, selected_animation_tree != null)

func _on_tree_item_selected() -> void:
	var selected_item: TreeItem = tree_view.get_selected()
	if not selected_item:
		ui_manager.set_path_display(path_label, "No selection", Color.GRAY)
		return
	
	var item_path = MetadataUtils.get_path_from_metadata(selected_item.get_metadata(0))
	var display_text = item_path if not item_path.is_empty() else "Root"
	ui_manager.set_path_display(path_label, display_text, Color.WHITE)

func _on_copy_pressed() -> void:
	var node_paths = _get_selected_node_paths()
	if node_paths.is_empty() or not selected_animation_tree:
		return
	copy_requested.emit(selected_animation_tree, node_paths)

func _on_paste_pressed() -> void:
	var selected_item: TreeItem = tree_view.get_selected()
	if not selected_item or not selected_animation_tree:
		return
	
	var target_path = MetadataUtils.get_path_from_metadata(selected_item.get_metadata(0))
	paste_requested.emit(selected_animation_tree, target_path)

func _on_delete_pressed() -> void:
	var node_paths = _get_selected_node_paths()
	if node_paths.is_empty() or not selected_animation_tree:
		return
	delete_requested.emit(selected_animation_tree, node_paths)

func _on_blueprint_pressed() -> void:
	var node_paths = _get_selected_node_paths()
	if not selected_animation_tree:
		TreeDebug.msg("No AnimationTree selected")
		return
	export_manager = ExportManager.new()
	
	var yaml_output: String
	if node_paths.is_empty():
		TreeDebug.msg("No nodes selected, generating YAML for entire tree")
		yaml_output = export_manager.export_tree_as_yaml(selected_animation_tree, [])
	else:
		yaml_output = export_manager.export_tree_as_yaml(selected_animation_tree, node_paths)
	await feedback.show_text("Generated YAML Based on your selection:", "Animation Tree YAML", yaml_output, true)

func _on_boilerplate_pressed() -> void:
	var node_paths = _get_selected_node_paths()
	if not selected_animation_tree:
		TreeDebug.msg("No AnimationTree selected")
		return
	
	export_manager = ExportManager.new(await _dependencies())
	
	var boilerplate = await feedback.show_text("This is automatically generated boilerplate based on your selection:", "Boilerplate of selected nodes",export_manager.export_tree_as_boilerplate(selected_animation_tree, node_paths), true)


# Get all container node paths in the entire tree
func _get_all_parents_node_paths() -> Array[String]:
	if not selected_animation_tree or not selected_animation_tree.tree_root:
		return []
	
	var container_paths: Array[String] = []
	var stack: Array = [{"node": selected_animation_tree.tree_root, "path": ""}]
	
	while stack.size() > 0:
		var current = stack.pop_back()
		var node = current.node
		var current_path = current.path
		
		if not is_instance_valid(node):
			continue
		
		# Check if current node is a container
		if node is AnimationNodeStateMachine or node is AnimationNodeBlendTree or node is AnimationNodeBlendSpace1D or node is AnimationNodeBlendSpace2D:
			if not current_path.is_empty():
				container_paths.append(current_path)
			
			# Get all children and add to stack
			var children = NodeUtils.get_container_children(node)
			for child_name in children:
				var child_path = current_path + "/" + child_name if not current_path.is_empty() else child_name
				var child_node = NodeUtils.get_node_at_path(selected_animation_tree.tree_root, child_path)
				if is_instance_valid(child_node):
					stack.append({"node": child_node, "path": child_path})
	
	return container_paths

# Get only selected node paths that are parent nodes
func _get_selected_node_parent_paths() -> Array[String]:
	var selected_items = SelectionUtils.get_selected_items(tree_view)
	var container_paths: Array[String] = []
	
	for item in selected_items:
		var path = MetadataUtils.get_path_from_metadata(item.get_metadata(0))
		if path.is_empty():
			continue
		
		var node = NodeUtils.get_node_at_path(selected_animation_tree.tree_root, path)
		if not is_instance_valid(node):
			continue
		
		# Check if node is a parent node
		if node is AnimationNodeStateMachine or node is AnimationNodeBlendTree or node is AnimationNodeBlendSpace1D or node is AnimationNodeBlendSpace2D:
			container_paths.append(path)
	
	return container_paths

func _get_selected_node_paths() -> Array[String]:
	var selected_items = SelectionUtils.get_selected_items(tree_view)
	var node_paths: Array[String] = []
	
	for item in selected_items:
		var path = MetadataUtils.get_path_from_metadata(item.get_metadata(0))
		if not path.is_empty():  # Skip root nodes for delete
			node_paths.append(path)
	
	return node_paths

func update_tree_view_after_operation() -> void:
	var current_state = state_manager.capture_tree_state(tree_view)
	await get_tree().process_frame
	
	_refresh_tree_view()
	await get_tree().process_frame
	
	state_manager.restore_tree_state(tree_view, current_state)

func _get_parent_path(path: String) -> String:
	if path.is_empty():
		return path
	
	var node = NodeUtils.get_node_at_path(selected_animation_tree.tree_root, path)
	if not is_instance_valid(node):
		return path
	
	if node is AnimationNodeStateMachine or node is AnimationNodeBlendTree or node is AnimationNodeBlendSpace1D or node is AnimationNodeBlendSpace2D:
		return path
	
	return NodeUtils.get_parent_path(path)

func _exit_tree() -> void:
	if editor_selection and editor_selection.selection_changed.is_connected(_on_editor_selection_changed):
		editor_selection.selection_changed.disconnect(_on_editor_selection_changed)
